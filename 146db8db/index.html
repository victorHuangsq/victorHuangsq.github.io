<!-- build time:Thu May 21 2020 21:44:46 GMT+0800 (中国标准时间) --><!DOCTYPE html><html class="theme-next pisces use-motion" lang="zh-Hans"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/images/w2-32x32.png?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/w2-16x16.png?v=5.1.4"><link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222"><meta name="keywords" content="u-boot,"><meta name="description" content="以下内容根据wowo的文章进行整理学习，多数内容拷贝自wowo的文章，在适当的地方添加自己的理解，在此非常感谢wowo的大神们。u-boot版本：2017.03开发板：imx8qxp meku-boot配置：未打开SPL前言在README文件中的Board Initialisation Flow章节有关于板级初始化流程的说明，如下：整个u-boot的流程都按照下面的规定走：123456789101"><meta name="keywords" content="u-boot"><meta property="og:type" content="article"><meta property="og:title" content="u-boot启动流程"><meta property="og:url" content="http://wowothink.com/146db8db/index.html"><meta property="og:site_name" content="wowothink"><meta property="og:description" content="以下内容根据wowo的文章进行整理学习，多数内容拷贝自wowo的文章，在适当的地方添加自己的理解，在此非常感谢wowo的大神们。u-boot版本：2017.03开发板：imx8qxp meku-boot配置：未打开SPL前言在README文件中的Board Initialisation Flow章节有关于板级初始化流程的说明，如下：整个u-boot的流程都按照下面的规定走：123456789101"><meta property="og:locale" content="zh-Hans"><meta property="og:image" content="https://pic.superbed.cn/item/5c9f8cf03a213b041769c82b"><meta property="og:image" content="https://pic.superbed.cn/item/5c9f8cf03a213b041769c82e"><meta property="og:image" content="https://pic.superbed.cn/item/5c9f8cf03a213b041769c834"><meta property="og:image" content="https://pic.superbed.cn/item/5c9f8cf03a213b041769c837"><meta property="og:image" content="https://pic.superbed.cn/item/5c9f8cf03a213b041769c829"><meta property="og:image" content="https://pic.superbed.cn/item/5c9f8db63a213b041769d167"><meta property="og:updated_time" content="2019-07-03T13:45:00.645Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="u-boot启动流程"><meta name="twitter:description" content="以下内容根据wowo的文章进行整理学习，多数内容拷贝自wowo的文章，在适当的地方添加自己的理解，在此非常感谢wowo的大神们。u-boot版本：2017.03开发板：imx8qxp meku-boot配置：未打开SPL前言在README文件中的Board Initialisation Flow章节有关于板级初始化流程的说明，如下：整个u-boot的流程都按照下面的规定走：123456789101"><meta name="twitter:image" content="https://pic.superbed.cn/item/5c9f8cf03a213b041769c82b"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Pisces",version:"5.1.4",sidebar:{position:"right",display:"post",offset:12,b2t:!0,scrollpercent:!0,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://wowothink.com/146db8db/"><title>u-boot启动流程 | wowothink</title><script>!function(e,t,a,n,c,s,o){e.GoogleAnalyticsObject=c,e[c]=e[c]||function(){(e[c].q=e[c].q||[]).push(arguments)},e[c].l=1*new Date,s=t.createElement(a),o=t.getElementsByTagName(a)[0],s.async=1,s.src=n,o.parentNode.insertBefore(s,o)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-146595331-1","auto"),ga("send","pageview")</script><script data-ad-client="ca-pub-1454282309009428" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-right page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">wowothink</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">thinking all the time</p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-folder"></i><br>归档</a></li><li class="menu-item menu-item-邮件"><a href="mailto:hsq_encourage@163.com" rel="section"><i class="menu-item-icon fa fa-fw fa-envelope"></i><br>邮件</a></li><li class="menu-item menu-item-博客"><a href="https://blog.csdn.net/encourage2011" rel="section"><i class="menu-item-icon fa fa-fw fa-crosshairs"></i><br>博客</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i> </span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"><input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://wowothink.com/146db8db/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Victor Huang"><meta itemprop="description" content=""><meta itemprop="image" content="/images/boy2.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="wowothink"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">u-boot启动流程</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-30T22:43:31+08:00">2019-03-30 </time></span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/u-boot/" itemprop="url" rel="index"><span itemprop="name">u-boot</span></a></span></span><div class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">字数统计&#58;</span> <span title="字数统计">5,244 </span><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span title="阅读时长">25</span></div></div></header><div class="post-body" itemprop="articleBody"><p>以下内容根据wowo的文章进行整理学习，多数内容拷贝自wowo的文章，在适当的地方添加自己的理解，在此非常感谢wowo的大神们。</p><ul><li>u-boot版本：2017.03</li><li>开发板：imx8qxp mek</li><li>u-boot配置：未打开SPL</li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在<code>README</code>文件中的<code>Board Initialisation Flow</code>章节有关于板级初始化流程的说明，如下：<br>整个u-boot的流程都按照下面的规定走：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">Board Initialisation Flow:</span><br><span class="line">--------------------------</span><br><span class="line"></span><br><span class="line">This is the intended start-up flow for boards. This should apply for both</span><br><span class="line">SPL and U-Boot proper (i.e. they both follow the same rules).</span><br><span class="line"></span><br><span class="line">Note: &quot;SPL&quot; stands for &quot;Secondary Program Loader,&quot; which is explained in</span><br><span class="line">more detail later in this file.</span><br><span class="line"></span><br><span class="line">At present, SPL mostly uses a separate code path, but the function names</span><br><span class="line">and roles of each function are the same. Some boards or architectures</span><br><span class="line">may not conform to this.  At least most ARM boards which use</span><br><span class="line">CONFIG_SPL_FRAMEWORK conform to this.</span><br><span class="line"></span><br><span class="line">Execution typically starts with an architecture-specific (and possibly</span><br><span class="line">CPU-specific) start.S file, such as:</span><br><span class="line"></span><br><span class="line">     - arch/arm/cpu/armv7/start.S</span><br><span class="line">     - arch/powerpc/cpu/mpc83xx/start.S</span><br><span class="line">     - arch/mips/cpu/start.S</span><br><span class="line"></span><br><span class="line">and so on. From there, three functions are called; the purpose and</span><br><span class="line">limitations of each of these functions are described below.</span><br><span class="line"></span><br><span class="line">lowlevel_init():</span><br><span class="line">     - purpose: essential init to permit execution to reach board_init_f()</span><br><span class="line">     - no global_data or BSS</span><br><span class="line">     - there is no stack (ARMv7 may have one but it will soon be removed)</span><br><span class="line">     - must not set up SDRAM or use console</span><br><span class="line">     - must only do the bare minimum to allow execution to continue to</span><br><span class="line">          board_init_f()</span><br><span class="line">     - this is almost never needed</span><br><span class="line">     - return normally from this function</span><br><span class="line"></span><br><span class="line">board_init_f():</span><br><span class="line">     - purpose: set up the machine ready for running board_init_r():</span><br><span class="line">          i.e. SDRAM and serial UART</span><br><span class="line">     - global_data is available</span><br><span class="line">     - stack is in SRAM</span><br><span class="line">     - BSS is not available, so you cannot use global/static variables,</span><br><span class="line">          only stack variables and global_data</span><br><span class="line"></span><br><span class="line">     Non-SPL-specific notes:</span><br><span class="line">     - dram_init() is called to set up DRAM. If already done in SPL this</span><br><span class="line">          can do nothing</span><br><span class="line"></span><br><span class="line">     SPL-specific notes:</span><br><span class="line">     - you can override the entire board_init_f() function with your own</span><br><span class="line">          version as needed.</span><br><span class="line">     - preloader_console_init() can be called here in extremis</span><br><span class="line">     - should set up SDRAM, and anything needed to make the UART work</span><br><span class="line">     - these is no need to clear BSS, it will be done by crt0.S</span><br><span class="line">     - must return normally from this function (don&apos;t call board_init_r()</span><br><span class="line">          directly)</span><br><span class="line"></span><br><span class="line">Here the BSS is cleared. For SPL, if CONFIG_SPL_STACK_R is defined, then at</span><br><span class="line">this point the stack and global_data are relocated to below</span><br><span class="line">CONFIG_SPL_STACK_R_ADDR. For non-SPL, U-Boot is relocated to run at the top of</span><br><span class="line">memory.</span><br><span class="line"></span><br><span class="line">board_init_r():</span><br><span class="line">     - purpose: main execution, common code</span><br><span class="line">     - global_data is available</span><br><span class="line">     - SDRAM is available</span><br><span class="line">     - BSS is available, all static/global variables can be used</span><br><span class="line">     - execution eventually continues to main_loop()</span><br><span class="line"></span><br><span class="line">     Non-SPL-specific notes:</span><br><span class="line">     - U-Boot is relocated to the top of memory and is now running from</span><br><span class="line">          there.</span><br><span class="line"></span><br><span class="line">     SPL-specific notes:</span><br><span class="line">     - stack is optionally in SDRAM, if CONFIG_SPL_STACK_R is defined and</span><br><span class="line">          CONFIG_SPL_STACK_R_ADDR points into SDRAM</span><br><span class="line">     - preloader_console_init() can be called here - typically this is</span><br><span class="line">          done by selecting CONFIG_SPL_BOARD_INIT and then supplying a</span><br><span class="line">          spl_board_init() function containing this call</span><br><span class="line">     - loads U-Boot or (in falcon mode) Linux</span><br></pre></td></tr></table></figure><p></p><a id="more"></a><hr><h2 id="u-boot入口"><a href="#u-boot入口" class="headerlink" title="u-boot入口"></a>u-boot入口</h2><p>在<code>arch/arm/cpu/armv8/start.S</code>文件中定义：<br>调用顺序为： <code>_start</code> → <code>lowlevel_init</code> → <code>_main</code></p><ul><li><code>_start</code>为u-boot启动后的第一个执行地址。之所以是第一个执行的地址，是在<code>arch/arm/cpu/armv8/u-boot.lds</code>链接文件中指定的。</li><li><code>lowlevel_init()</code>一般不需要实现，现在基本不用了。</li><li><code>_main</code>为arm公共的，在<code>./arch/arm/lib/crt0_64.S</code>中定义，下面说明<code>_main</code>的实现。</li></ul><hr><h2 id="main简要说明"><a href="#main简要说明" class="headerlink" title="_main简要说明"></a><code>_main</code>简要说明</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* This file handles the target-independent stages of the U-Boot</span></span><br><span class="line"><span class="comment">* start-up where a C runtime environment is needed. Its entry point</span></span><br><span class="line"><span class="comment">* is _main and is branched into from the target's start.S file.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* _main execution sequence is:</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 1. Set up initial environment for calling board_init_f().</span></span><br><span class="line"><span class="comment">*    This environment only provides a stack and a place to store</span></span><br><span class="line"><span class="comment">*    the GD ('global data') structure, both located in some readily</span></span><br><span class="line"><span class="comment">*    available RAM (SRAM, locked cache...). In this context, VARIABLE</span></span><br><span class="line"><span class="comment">*    global data, initialized or not (BSS), are UNAVAILABLE; only</span></span><br><span class="line"><span class="comment">*    CONSTANT initialized data are available. GD should be zeroed</span></span><br><span class="line"><span class="comment">*    before board_init_f() is called.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 2. Call board_init_f(). This function prepares the hardware for</span></span><br><span class="line"><span class="comment">*    execution from system RAM (DRAM, DDR...) As system RAM may not</span></span><br><span class="line"><span class="comment">*    be available yet, , board_init_f() must use the current GD to</span></span><br><span class="line"><span class="comment">*    store any data which must be passed on to later stages. These</span></span><br><span class="line"><span class="comment">*    data include the relocation destination, the future stack, and</span></span><br><span class="line"><span class="comment">*    the future GD location.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 3. Set up intermediate environment where the stack and GD are the</span></span><br><span class="line"><span class="comment">*    ones allocated by board_init_f() in system RAM, but BSS and</span></span><br><span class="line"><span class="comment">*    initialized non-const data are still not available.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 4a.For U-Boot proper (not SPL), call relocate_code(). This function</span></span><br><span class="line"><span class="comment">*    relocates U-Boot from its current location into the relocation</span></span><br><span class="line"><span class="comment">*    destination computed by board_init_f().</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 4b.For SPL, board_init_f() just returns (to crt0). There is no</span></span><br><span class="line"><span class="comment">*    code relocation in SPL.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 5. Set up final environment for calling board_init_r(). This</span></span><br><span class="line"><span class="comment">*    environment has BSS (initialized to 0), initialized non-const</span></span><br><span class="line"><span class="comment">*    data (initialized to their intended value), and stack in system</span></span><br><span class="line"><span class="comment">*    RAM (for SPL moving the stack and GD into RAM is optional - see</span></span><br><span class="line"><span class="comment">*    CONFIG_SPL_STACK_R). GD has retained values set by board_init_f().</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">TODO:</span> For SPL, implement stack relocation on AArch64.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 6. For U-Boot proper (not SPL), some CPUs have some work left to do</span></span><br><span class="line"><span class="comment">*    at this point regarding memory, so call c_runtime_cpu_setup.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 7. Branch to board_init_r().</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* For more information see 'Board Initialisation Flow in README.</span></span><br></pre></td></tr></table></figure><p>简单翻译如下：</p><ul><li>1.创建调用<code>board_init_f()</code>的C运行环境。关于C运行环境，可以参照最后一章的链接；</li><li>2.调用<code>board_init_f()</code>做先前的板级初始化动作；</li><li>3.设置中间环境，其中的堆栈和<code>GD</code>是由系统RAM中调用<code>board_init_f()</code>进行分配的；</li><li>4a.调用<code>relocate_code</code>重新定位u-boot；</li><li>4b.对于SPL，不用重新定位；</li><li>5.为调用<code>board_init_r()</code>设置最后的环境；</li></ul><hr><h2 id="main的详细流程如下："><a href="#main的详细流程如下：" class="headerlink" title="_main的详细流程如下："></a><code>_main</code>的详细流程如下：</h2><ul><li><p>1.设置初始的堆栈，基址由<code>CONFIG_SYS_INIT_SP_ADDR</code>定义。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#if defined(CONFIG_SPL_BUILD) &amp;&amp; defined(CONFIG_SPL_STACK)</span><br><span class="line">    ldr x0, =(CONFIG_SPL_STACK)</span><br><span class="line">#else</span><br><span class="line">    ldr x0, =(CONFIG_SYS_INIT_SP_ADDR)</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></li><li><p>2.分配<code>global data</code>所需的空间，将堆栈16 bits对齐之后，调用<code>board_init_f_alloc_reserve</code>接口，从堆栈开始的地方，为u-boot的<code>global data（struct global_data）</code>分配空间。<br>也就是调用<code>common/init/board_init.c</code>的<code>board_init_f_alloc_reserve()</code>函数。按照之前的说明，<code>_main</code>主要是为了调用<code>board_init_f()</code>初始化环境。这个环境提供了stack和放置<code>GD</code>数据结构的地方，这两者都放在可读的RAM(SRAM或锁住的cached等)。在上下文环境中<code>GD</code>、已初始化或未初始化的<code>BSS</code>是不可用的。只有<code>初始化的常量</code>可以使用。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">`board_init_f_alloc_reserve()`函数的定义如下：</span><br><span class="line">/*                       </span><br><span class="line">* Allocate reserved space for use as &apos;globals&apos; from &apos;top&apos; address and</span><br><span class="line">* return &apos;bottom&apos; address of allocated space</span><br><span class="line">*</span><br><span class="line">* Notes:</span><br><span class="line">*</span><br><span class="line">* Actual reservation cannot be done from within this function as</span><br><span class="line">* it requires altering the C stack pointer, so this will be done by</span><br><span class="line">* the caller upon return from this function.</span><br><span class="line">*</span><br><span class="line">* IMPORTANT:</span><br><span class="line">*</span><br><span class="line">* Alignment constraints may differ for each &apos;chunk&apos; allocated. For now:</span><br><span class="line">*</span><br><span class="line">* - GD is aligned down on a 16-byte boundary</span><br><span class="line">*</span><br><span class="line">*  - the early malloc arena is not aligned, therefore it follows the stack</span><br><span class="line">*   alignment constraint of the architecture for which we are bulding.</span><br><span class="line">*</span><br><span class="line">*  - GD is allocated last, so that the return value of this functions is</span><br><span class="line">*   both the bottom of the reserved area and the address of GD, should</span><br><span class="line">*   the calling context need it.</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">ulong board_init_f_alloc_reserve(ulong top)</span><br><span class="line">&#123;</span><br><span class="line">    /* Reserve early malloc arena */</span><br><span class="line">#if defined(CONFIG_SYS_MALLOC_F)</span><br><span class="line">    top -= CONFIG_SYS_MALLOC_F_LEN;</span><br><span class="line">#endif</span><br><span class="line">    /* LAST : reserve GD (rounded up to a multiple of 16 bytes) */</span><br><span class="line">    top = rounddown(top-sizeof(struct global_data), 16);</span><br><span class="line"></span><br><span class="line">    return top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数主要用来分配堆栈区域。<code>top</code>地址为<code>CONFIG_SYS_INIT_SP_ADDR</code>，如果定义了<code>CONFIG_SYS_MALLOC_F</code>，reserve 空间的起始地址为<code>CONFIG_SYS_INIT_SP_ADDR - CONFIG_SYS_MALLOC_F_LEN</code> ~ <code>CONFIG_SYS_INIT_SP_ADDR</code>。返回值为指向<code>GD</code>的地址为<code>top-sizeof(struct global_data)</code>。初始化堆栈和reserve空间后的内存layout如下<a href="https://blog.csdn.net/ooonebook/article/details/53013545" target="_blank" rel="noopener">global_data介绍</a>：<br>执行<code>board_init_f_alloc_reserve()</code>后，sp指针就指向了<code>GD</code>，并把值存到<code>x18</code>寄存器里。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bl  board_init_f_alloc_reserve</span><br><span class="line">mov sp, x0</span><br><span class="line">/* set up gd here, outside any C code */</span><br><span class="line">mov x18, x0</span><br></pre></td></tr></table></figure><p></p><p>在<code>arch/arm/include/asm/global_data.h</code>文件中定义了指针<code>gd</code>的值从<code>x18</code>寄存器取得，这样的话，我们在后续的过程中就可以使用<code>gd</code>了。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#ifdef CONFIG_ARM64</span><br><span class="line">#define DECLARE_GLOBAL_DATA_PTR     register volatile gd_t *gd asm (&quot;x18&quot;)</span><br><span class="line">#else</span><br><span class="line">#define DECLARE_GLOBAL_DATA_PTR     register volatile gd_t *gd asm (&quot;r9&quot;)</span><br><span class="line">#endif</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p></p><p>注：在ARM中<code>x0-x7</code>寄存器用于函数调用时参数传递，<code>x0</code>一般用作返回值。<br>该函数调用之后，DDR SDRAM的layout如下：</p><ul><li><p>3.<code>GD</code>的空间分配后，调用<code>board_init_f_init_reserve</code>，初始化<code>global data</code>，所谓的初始化，无非就是一些清零操作。<br>赋值<code>gd_ptr</code>和<code>gd-&gt;malloc_base</code>。执行完之后，DDR SDRAM的layout如下：<br><img src="https://pic.superbed.cn/item/5c9f8cf03a213b041769c82b" alt="图1"></p></li><li><p>4.调用<code>common/board_f.c</code>的<code>board_init_f()</code>函数，参数为0。以下对该函数进行详细的说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov x0, #0</span><br><span class="line">bl  board_init_f</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="board-init-f-函数"><a href="#board-init-f-函数" class="headerlink" title="board_init_f()函数"></a><code>board_init_f()</code>函数</h2><p>u-boot将需要在<code>board_init_f</code>中初始化的内容，抽象为一系列API。这些API由u-boot声明，由平台的开发者根据实际情况实现。该函数在<code>common/board_f.c</code>文件中定义。<br>对<code>global data</code>进行简单的初始化之后，调用位于<code>init_sequence_f</code>数组中的各种初始化API，进行各式各样的初始化动作。这些API有些需要板级厂商进行实现。以下是对<code>init_sequence_f</code>数组中相关的API进行说明。</p><ul><li>1.调用<code>setup_mon_len()</code>设置<code>gd-&gt;mon_len</code>的值，这个值表示u-boot代码大小。</li><li><p>2.调用<code>fdtdec_setup()</code>设置<code>gd-&gt;fdt_blob</code>的值。<br>如果打开了<code>CONFIG_OF_CONTROL</code>，也就是u-boot使用dts，那么会调用<code>fdtdec_setup</code>，设置<code>gd-&gt;fdt_blob</code>指针（即device tree所在的存储位置）的值。对ARM平台来说，u-boot的Makefile会通过连接脚本，将dtb文件打包到u-boot image的<code>__dtb_dt_begin</code>位置处，因此不需要特别关心。<br><code>gd-&gt;fdt_blob = (ulong *)&amp;_end;</code>，因此通过<code>u-boot.map</code>文件查找到<code>_end</code>的地址为<code>0x0000000080060570 _end = .</code>，在u-boot的命令行模式读取该段内存数据<code>md 80060570</code>，显示如下：<br>这段内容开始就是<code>fdt</code>的内容，也可以与dtb的内容对应起来。<br>在<code>fdtdec_prepare_fdt()</code>函数中，会通过<code>gd-&gt;fdt_blob</code>指向区域的值来判断是否是device tree。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">=&gt; md 80060570</span><br><span class="line">80060570: edfe0dd0 6aa20000 48000000 d49c0000    .......j...H....</span><br><span class="line">80060580: 28000000 11000000 10000000 00000000    ...(............</span><br><span class="line">80060590: 96050000 8c9c0000 00000000 00000080    ................</span><br><span class="line">800605a0: 00000000 00004000 00000000 00000000    .....@..........</span><br><span class="line">800605b0: 00000000 00000000 01000000 00000000    ................</span><br><span class="line">800605c0: 03000000 24000000 00000000 2c6c7366    .......$....fsl,</span><br><span class="line">800605d0: 38786d69 2d707871 6464706c 612d3472    imx8qxp-xxxxx4-a</span><br><span class="line">800605e0: 00326d72 2c6c7366 38786d69 00707871    rm2.fsl,imx8qxp.</span><br><span class="line">800605f0: 03000000 04000000 0b000000 01000000    ................</span><br><span class="line">80060600: 03000000 04000000 1c000000 02000000    ................</span><br><span class="line">80060610: 03000000 04000000 2b000000 02000000    ...........+....</span><br><span class="line">80060620: 03000000 1f000000 37000000 65657246    ...........7Free</span><br><span class="line">80060630: 6c616373 2e692065 5138584d 4c205058    scale i.MX8QXP X</span><br><span class="line">80060640: 52444450 52412034 0000324d 01000000    XXXX4 ARM2......</span><br><span class="line">80060650: 73757063 00000000 03000000 04000000    cpus............</span><br><span class="line">80060660: 1c000000 02000000 03000000 04000000    ................</span><br></pre></td></tr></table></figure></li><li><p>3.调用<code>initf_malloc()</code>设置<code>gd-&gt;malloc_limit</code>分配空间限制为<code>CONFIG_SYS_MALLOC_F_LEN</code>。</p></li><li><p>4.调用<code>initf_dm()</code>进行u-boot的driver model的初始化，在这里回去解析fdt的设备并注册与之匹配的驱动。关于这部分的内容，可以参照<a href="https://blog.csdn.net/ooonebook/article/details/53234020" target="_blank" rel="noopener">uboot 驱动模型</a></p></li><li><p>5.调用<code>env_init()</code>设置<code>gd-&gt;env_addr</code>环境变量的地址。<br><code>env_init</code>在<code>common/env_mmc.c</code>中定义(文件名不一定)。里面用到了个全局数组<code>default_environment[]</code>，该数组在<code>include/env_default.h</code>中定义，数组中定义好多环境变量相关的，我们可以通过在u-boot终端敲<code>pirntenv</code>命令打印环境变量。<br>环境变量的值可以在编译u-boot之后查看<code>u-boot.cfg</code>中找到。</p></li><li>6.调用<code>init_baud_rate()</code>设置<code>gd-&gt;baudrate</code>波特率，也就是从环境变量中获取<code>baudrate</code>的值。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gd-&gt;baudrate = getenv_ulong(&quot;baudrate&quot;, 10, CONFIG_BAUDRATE);</span><br></pre></td></tr></table></figure></li></ul><p>获取当前使用串口波特率，可以有两个途径（优先级从高到低），从<code>baudrate</code>中获取；从<code>CONFIG_BAUDRATE</code>配置项获取。</p><ul><li>7.调用<code>serial_init()</code>和<code>console_init_f()</code>初始化串口相关的设备和驱动。<br>初始化硬件串口，由原厂实现，最终在<code>drivers/serial/</code>文件中实现。</li><li><p>8.<code>display_options()</code>显示u-boot的版本信息和编译信息，具体的定义是编译自动生成在：<br><code>include/generated/version_autogenerated.h</code>文件中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define U_BOOT_VERSION_STRING U_BOOT_VERSION &quot; (&quot; U_BOOT_DATE &quot; - &quot; \</span><br><span class="line">    U_BOOT_TIME &quot; &quot; U_BOOT_TZ &quot;)&quot; CONFIG_IDENT_STRING</span><br></pre></td></tr></table></figure></li><li><p>9.调用<code>display_text_info()</code>打印u-boot代码段的起始和结束地址，以及BSS段的起始和结束地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;U-Boot code: %08lX -&gt; %08lX  BSS: -&gt; %08lX\n&quot;,</span><br><span class="line">    text_base, bss_start, bss_end);</span><br></pre></td></tr></table></figure></li></ul><p>上述两条打印语句，在串口打印的内容如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[    0.267] U-Boot 2017.03-g3d43db2-dirty (Mar 08 2018 - 16:12:42 +0800)</span><br><span class="line">[    0.284] U-Boot code: 80020000 -&gt; 80061430  BSS: -&gt; 800984F8</span><br></pre></td></tr></table></figure><p></p><p>因此，内存空间由上到下分别是：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">--------bss_end  --------------高地址</span><br><span class="line"></span><br><span class="line">         BSS 段</span><br><span class="line"></span><br><span class="line">--------bss_start  -------------</span><br><span class="line"></span><br><span class="line">         代码段</span><br><span class="line"></span><br><span class="line">-------- text_base(CONFIG_SYS_TEXT_BASE)------ 低地址</span><br></pre></td></tr></table></figure><p></p><p><code>text_base</code>由<code>CONFIG_SYS_TEXT_BASE</code>来决定，<code>text_base</code>也就是<code>start.S</code>中执行<code>_start</code>开始的地方，也就是u-boot的代码段。但是<code>bss_start</code>和<code>bss_end</code>的地址在哪里决定还没搞清楚。<br>这些内容也可以通过编译出来的u-boot.map文件查看到。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Address of section .text set to 0x80020000</span><br><span class="line">                0x0000000000000000                . = 0x0</span><br><span class="line">                0x0000000000000000                . = ALIGN (0x8)</span><br><span class="line"></span><br><span class="line">.text           0x0000000080020000    0x2a898</span><br><span class="line">*(.__image_copy_start)</span><br><span class="line">.__image_copy_start</span><br><span class="line">                0x0000000080020000        0x0 arch/arm/lib/built-in.o</span><br><span class="line">                0x0000000080020000                __image_copy_start</span><br><span class="line">arch/arm/cpu/armv8/start.o(.text*)</span><br><span class="line">.text          0x0000000080020000      0x110 arch/arm/cpu/armv8/start.o</span><br><span class="line">                0x0000000080020000                _start</span><br></pre></td></tr></table></figure><p></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.bss_start      0x0000000080061430        0x0</span><br><span class="line">*(.__bss_start)</span><br><span class="line">.__bss_start   0x0000000080061430        0x0 arch/arm/lib/built-in.o</span><br><span class="line">                0x0000000080061430                __bss_start</span><br><span class="line">               </span><br><span class="line">.bss_end        0x00000000800984f8        0x0</span><br><span class="line">*(.__bss_end)</span><br><span class="line">.__bss_end     0x00000000800984f8        0x0 arch/arm/lib/built-in.o</span><br><span class="line">                0x00000000800984f8                __bss_end</span><br></pre></td></tr></table></figure><ul><li>10.调用<code>print_cpuinfo()</code>打印CPU的相关信息。</li><li><p>11.调用<code>show_board_info()</code>打印板级的相关信息，在<code>common/board_info.c</code>文件中定义，主要去获取dts中<code>model</code>节点的信息，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">* If the root node of the DTB has a &quot;model&quot; property, show it.</span><br><span class="line">* Then call checkboard().</span><br><span class="line">*/ </span><br><span class="line">int __weak show_board_info(void)</span><br><span class="line">&#123;</span><br><span class="line">#ifdef CONFIG_OF_CONTROL</span><br><span class="line">    DECLARE_GLOBAL_DATA_PTR;</span><br><span class="line">    const char *model;</span><br><span class="line"></span><br><span class="line">    model = fdt_getprop(gd-&gt;fdt_blob, 0, &quot;model&quot;, NULL);</span><br><span class="line"></span><br><span class="line">    if (model)</span><br><span class="line">        printf(&quot;Model: %s\n&quot;, model);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    return checkboard();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>12.调用<code>dram_init()</code>初始化系统的DDR，<code>dram_init</code>应该由平台相关的代码实现。<br>如果DDR已经初始化过了，则不需要重新初始化，只需要把DDR信息(DDR大小和初始地址)保存在<code>global data</code>中即可。在我们这里，将DDR的大小信息保存在<code>gd-&gt;ram_size</code>中。<br>按照u-boot的说明，调用<code>dram_init()</code>之后，就要去分配DDR SDRAM的的空间以及<code>relocate u-boot</code>的代码了，注释说明如下，更多关于<code>relocate u-boot</code>，请见下文分解。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">* Now that we have DRAM mapped and working, we can</span><br><span class="line">* relocate the code and continue running from DRAM.</span><br><span class="line">*</span><br><span class="line">* Reserve memory at end of RAM for (top down in that order):</span><br><span class="line">*  - area that won&apos;t get touched by U-Boot and Linux (optional)</span><br><span class="line">*  - kernel log buffer</span><br><span class="line">*  - protected RAM </span><br><span class="line">*  - LCD framebuffer</span><br><span class="line">*  - monitor code  </span><br><span class="line">*  - board info struct</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="u-boot-relocate"><a href="#u-boot-relocate" class="headerlink" title="u-boot relocate"></a>u-boot relocate</h2><p>这部分的内容同样属于上一篇文章中<code>board_init_f()</code>的范畴内，主要是为了说明方便，本文单独成文描述u-boot relocate。<br>在说明relocate之前，先说为啥要relocate：</p><ul><li>在以前的板子上，u-boot有可能是运行在NOR FLASH或ROM上，空间很小，执行慢，而且不支持写操作，DDR SDRAM初始化完毕之后，需要将其relocate到DDR SDRAM去运行，空间大，执行的速度也比较快，支持写操作；</li><li>考虑到后续的kernel是在DDR SDRAM的低端位置解压缩并执行的，为了避免麻烦，u-boot将使用DRAM的顶端地址，即<code>gd-&gt;ram_top</code>所代表的位置；</li></ul><h3 id="reserve空间"><a href="#reserve空间" class="headerlink" title="reserve空间"></a>reserve空间</h3><p>以下内容都是在DDR SDRAM高地址为relocate做reserve的准备。</p><ul><li><p>1.调用<code>setup_dest_addr()</code>设置u-boot的relocaddr地址，通过<code>gd-&gt;ram_size</code>和<code>CONFIG_SYS_SDRAM_BASE</code>(DDR的起始地址)确定<code>gd-&gt;ram_top</code>和<code>gd-&gt;relocaddr</code>，也就是将u-boot重定位到DDR最高的地址，执行完之后<code>gd-&gt;relocaddr = gd-&gt;ram_top</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#ifdef CONFIG_SYS_SDRAM_BASE</span><br><span class="line">    gd-&gt;ram_top = CONFIG_SYS_SDRAM_BASE;</span><br><span class="line">#endif</span><br><span class="line">    gd-&gt;ram_top += get_effective_memsize();</span><br><span class="line">    gd-&gt;ram_top = board_get_usable_ram_top(gd-&gt;mon_len);</span><br><span class="line">    gd-&gt;relocaddr = gd-&gt;ram_top;</span><br><span class="line">    printf(&quot;Ram top: %08lX\n&quot;, (ulong)gd-&gt;ram_top);</span><br></pre></td></tr></table></figure></li><li><p>2.特殊功能所需空间的reserve，如<code>log buffer</code>、<code>MMU page table</code>、<code>LCD fb buffer</code>、<code>trace buffer</code>等等。</p></li><li>3.调用<code>reserve_uboot()</code>，reserve <code>gd-&gt;mon_len</code>和<code>U-Boot code</code>, <code>data &amp; bss</code>的空间。分配完之后，DDR SDRAM布局如下：<br><img src="https://pic.superbed.cn/item/5c9f8cf03a213b041769c82e" alt="图2"></li><li><p>4.调用<code>reserve_malloc()</code>，reserve malloc的空间，大小为<code>TOTAL_MALLOC_LEN</code>，该在<code>include/common.h</code>文件中定义，定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#if defined(CONFIG_ENV_IS_EMBEDDED)</span><br><span class="line">#define TOTAL_MALLOC_LEN    CONFIG_SYS_MALLOC_LEN</span><br><span class="line">#elif ( ((CONFIG_ENV_ADDR+CONFIG_ENV_SIZE) &lt; CONFIG_SYS_MONITOR_BASE) || \</span><br><span class="line">    (CONFIG_ENV_ADDR &gt;= (CONFIG_SYS_MONITOR_BASE + CONFIG_SYS_MONITOR_LEN)) ) || \</span><br><span class="line">      defined(CONFIG_ENV_IS_IN_NVRAM)</span><br><span class="line">#define TOTAL_MALLOC_LEN    (CONFIG_SYS_MALLOC_LEN + CONFIG_ENV_SIZE)</span><br><span class="line">#else</span><br><span class="line">#define TOTAL_MALLOC_LEN    CONFIG_SYS_MALLOC_LEN</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></li><li><p>5.调用<code>reserve_board()</code>为<code>struct bd_info</code>分配空间，此时可以得到<code>gd-&gt;bd</code>并将其初始化为0。<br>执行完之后，DDR SDRAM布局如下：<br><img src="https://pic.superbed.cn/item/5c9f8cf03a213b041769c834" alt="图3"></p></li><li>6.调用<code>reserve_global_data()</code>为<code>struct global_data</code>分配空间，此时可以得到<code>gd-&gt;new_gd</code>的值。<br>执行完之后，DDR SDRAM布局如下：<br><img src="https://pic.superbed.cn/item/5c9f8cf03a213b041769c837" alt="图4"></li><li>7.调用<code>reserve_fdt()</code>通过<code>gd-&gt;fdt_blob</code>计算出<code>gd-&gt;fdt_size</code>的大小，未fdt分配空间，得到<code>gd-&gt;new_fdt</code>的值。</li><li>8.调用<code>reserve_stacks()</code>设置16字节的irq stack，得到<code>gd-&gt;irq_sp</code>的值。<br><img src="https://pic.superbed.cn/item/5c9f8cf03a213b041769c829" alt="图5"></li><li>9.调用<code>setup_dram_config()</code>做RAM configuration，主要是为了填充<code>gd-&gt;bd-&gt;bi_dram</code>字段，这一部分内容由厂商实现。</li><li>10.调用<code>display_new_sp()</code>打印当前的<code>gd-&gt;start_addr_sp</code>的值，也就是堆栈指针。至此，reserve空间已完毕，最终的DDR SDRAM的布局如下：<br><img src="https://pic.superbed.cn/item/5c9f8db63a213b041769d167" alt="图6"></li></ul><hr><h3 id="relocate-u-boot"><a href="#relocate-u-boot" class="headerlink" title="relocate u-boot"></a>relocate u-boot</h3><p>实际上的relocate u-boot就是将以前在低地址的内容拷贝到高地址与之对应的位置，并重新赋值指针。</p><ul><li><p>1.调用<code>reloc_fdt()</code>将<code>gd-&gt;fdt_blob</code>的内容拷贝到<code>gd-&gt;new_fdt</code>，拷贝<code>gd-&gt;fdt_size</code>这么多。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static int reloc_fdt(void)</span><br><span class="line">&#123;</span><br><span class="line">#ifndef CONFIG_OF_EMBED</span><br><span class="line">    if (gd-&gt;flags &amp; GD_FLG_SKIP_RELOC)</span><br><span class="line">        return 0;</span><br><span class="line">    if (gd-&gt;new_fdt) &#123;  </span><br><span class="line">        memcpy(gd-&gt;new_fdt, gd-&gt;fdt_blob, gd-&gt;fdt_size);</span><br><span class="line">        gd-&gt;fdt_blob = gd-&gt;new_fdt;   </span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line"> </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>2.调用<code>setup_reloc()</code>计算u-boot代码空间到relocation的位置的偏移，也就是<code>gd-&gt;reloc_off = gd-&gt;relocaddr - CONFIG_SYS_TEXT_BASE;</code>，拷贝<code>GD</code>内容到<code>new_gd</code>，也就是：<code>memcpy(gd-&gt;new_gd, (char *)gd, sizeof(gd_t));</code>。<br>将最重要的<code>GD</code>内容拷贝到新的地址后，后面我们就可以根据<code>GD</code>来做很多事。至此，<code>init_sequence_f[]</code>中定义的函数指针都已执行完毕，也就是<code>board_init_f()</code>函数执行完毕，接下来就会到<code>_main</code>中执行relocate的动作了。</p></li><li>3.调用<code>relocate_code()</code>将u-boot的存放地址根据<code>board_init_f()</code>计算后的地址重新改变，这部分涉及到很多汇编代码以及<code>位置无关代码</code>原理，其中还有很多不明白的，后续等明白了再补充。</li></ul><hr><h2 id="board-init-r函数"><a href="#board-init-r函数" class="headerlink" title="board_init_r函数"></a><code>board_init_r</code>函数</h2><p>在<code>_main</code>的最后，调用<code>board_init_r()</code>函数，参数1为<code>gd-&gt;new_gd</code>，参数2为<code>gd-&gt;relocaddr</code>。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/* call board_init_r(gd_t *id, ulong dest_addr) */</span><br><span class="line">mov x0, x18             /* gd_t */</span><br><span class="line">ldr x1, [x18, #GD_RELOCADDR]    /* dest_addr */</span><br><span class="line">b   board_init_r            /* PC relative jump */</span><br></pre></td></tr></table></figure><p></p><p><code>board_init_r()</code>函数在<code>common/board_r.c</code>文件中定义，这个函数中同样也会去执行由<code>init_sequence_r[]</code>定义的一系列函数指针。</p><ul><li>1.调用<code>initr_trace()</code>，初始化并使能u-boot的tracing system。</li><li>2.调用<code>initr_reloc()</code>，标记<code>gd-&gt;flags</code>为<code>GD_FLG_RELOC | GD_FLG_FULL_MALLOC_INIT</code>表示: Code was relocated to RAM and Full malloc() is ready。</li><li>3.调用<code>initr_caches()</code>去使能<code>dcache</code>、<code>icache</code>。</li><li>4.调用<code>initr_reloc_global_data()</code>得到<code>monitor_flash_len</code>的值。</li><li>5.调用<code>initr_malloc()</code>初始化从<code>malloc_start</code>~<code>gd-&gt;relocaddr</code>总共<code>TOTAL_MALLOC_LEN</code>大小空间为0。</li><li>6.调用<code>initr_dm()</code>: Save the pre-reloc driver model and start a new one。</li><li>7.调用<code>board_init()</code>做板级初始化，这部分的内容一般定义在<code>board/vendor/xxx_board/xxx_board.c</code>文件下，我这里的路径为<code>board/freescale/imx8qxp_mek/imx8qxp_mek.c</code>。</li><li>8.调用<code>initr_serial()</code>重新初始化初始化串口，在relocate之前，调用<code>serial_init()</code>进行初始化，在relocate之后(也就是这里)，调用<code>initr_serial()</code> -&gt; <code>serial_initialize()</code> -&gt; <code>serial_init()</code>。<br>最终也是调用<code>serial_init()</code>做串口的初始化。</li><li>9.调用<code>initr_mmc()</code>做mmc的初始化，相关内容在<code>drivers/mmc/mmc.c</code>文件中定义。</li><li>10.调用<code>initr_env()</code>初始化环境变量，并从环境变量获取到<code>load_addr</code>的值，这个环境变量在<code>default_environment[]</code>就已经设定进去了。</li><li>11.调用<code>console_init_r()</code>: fully init console as a device。</li><li>12.调用<code>board_late_init()</code>，功能类似<code>board_init()</code>，涉及的配置项有<code>CONFIG_BOARD_LATE_INIT</code>。</li><li>13.调用<code>run_main_loop()</code>执行到<code>main_loop()</code>，开始命令行操作。</li></ul><hr><h2 id="main-loop"><a href="#main-loop" class="headerlink" title="main_loop()"></a><code>main_loop()</code></h2><p>在<code>common/main.c</code>文件中定义，这里只关注后面的几个函数调用。从这里开始，基本上都是通过环境变量来判断做什么事情。<code>cli_xxx</code>是<code>Command Line Interface</code>的简写。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/* We come here after U-Boot is initialised and ready to process commands */</span><br><span class="line">void main_loop(void)</span><br><span class="line">&#123;</span><br><span class="line">    const char *s;</span><br><span class="line"></span><br><span class="line">    bootstage_mark_name(BOOTSTAGE_ID_MAIN_LOOP, &quot;main_loop&quot;);</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_VERSION_VARIABLE</span><br><span class="line">    setenv(&quot;ver&quot;, version_string);  /* set version variable */</span><br><span class="line">#endif /* CONFIG_VERSION_VARIABLE */</span><br><span class="line"></span><br><span class="line">    cli_init();</span><br><span class="line"></span><br><span class="line">    run_preboot_environment_command();</span><br><span class="line"></span><br><span class="line">#if defined(CONFIG_UPDATE_TFTP)   </span><br><span class="line">    update_tftp(0UL, NULL, NULL);</span><br><span class="line">#endif /* CONFIG_UPDATE_TFTP */</span><br><span class="line"></span><br><span class="line">    s = bootdelay_process();</span><br><span class="line">    if (cli_process_fdt(&amp;s))</span><br><span class="line">        cli_secure_boot_cmd(s);</span><br><span class="line"></span><br><span class="line">    autoboot_command(s);</span><br><span class="line"></span><br><span class="line">    cli_loop();</span><br><span class="line">    panic(&quot;No CLI available&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><ul><li>1.调用<code>bootdelay_process()</code>主要是为了设置启动延时使用，可以通过<code>CONFIG_BOOTDELAY</code>设置启动延时多少秒。通过<code>s = getenv(&quot;bootcmd&quot;);</code>获取<code>bootcmd</code>的值做为返回值。<br>调用<code>process_fdt_options(gd-&gt;fdt_blob);</code>从device tree判断是否有<code>kernel-offset</code>和<code>rootdisk-offset</code>的说明，如果有的话，那么设置<code>kernaddr</code>和<code>rootaddr</code>的环境变量。<br>从这个来看，支持从device tree中传递去设置环境变量。</li><li>2.调用<code>cli_process_fdt()</code>判断是否有secure boot相关的，这里没有。</li><li>3.调用<code>autoboot_command()</code>执行环境变量<code>bootcmd</code>的内容，也就是执行相关的命令，在<code>common/autoboot.c</code>文件中定义。通过命令，就可以启动Linux Kernel了。</li></ul><hr><h2 id="Boot-Linux"><a href="#Boot-Linux" class="headerlink" title="Boot Linux"></a>Boot Linux</h2><p>在<code>README</code>中有<code>Boot Linux</code>章节用来描述如何启动linux。<code>bootm</code>命令用来启动存储在RAM或Flash上的程序，<code>bootargs</code>环境变量用来传递参数给kernel。<br>我的理解是，u-boot从eMMC读取Image到DDR启动linux，主要是有以下几个步骤：</p><ul><li>1.<code>setenv bootargs</code>，设置<code>bootargs</code>用来传递参数给kernel。</li><li>2.<code>mmc read ram_addr emmc_blk cnt</code>，从emmc读取Image并load到DDR中去。</li><li>3.<code>checkimage ram_addr</code>检查镜像是否正确（非必须）。</li><li>4.<code>booti kernel_start_addr ramdisk_start_addr dtb_start_addr</code>，从ram中的去启动kernel、ramdisk、dtb，<code>booti</code>的用法如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[    2.787] =&gt; help booti</span><br><span class="line">booti - boot arm64 Linux Image image from memory</span><br><span class="line"></span><br><span class="line">[  210.831] Usage:</span><br><span class="line">[  210.833] booti [addr [initrd[:size]] [fdt]]</span><br><span class="line">[  210.838] - boot arm64 Linux Image stored in memory</span><br><span class="line">[  210.843]     The argument &apos;initrd&apos; is optional and specifies the address</span><br><span class="line">[  210.849]     of an initrd in memory. The optional parameter &apos;:size&apos; allows</span><br><span class="line">[  210.856]     specifying the size of a RAW initrd.</span><br><span class="line">[  210.860]     Since booting a Linux kernel requires a flat device-tree, a</span><br><span class="line">[  210.867]     third argument providing the address of the device-tree blob</span><br><span class="line">[  210.874]     is required. To boot a kernel with a device-tree blob but</span><br><span class="line">[  210.880]     without an initrd image, use a &apos;-&apos; for the initrd argument.</span><br></pre></td></tr></table></figure></li></ul><p>关于u-boot的命令行模式和<code>bootm/booti</code>等启动命令的原理，可以参照下面的文章：</p><hr><h2 id="U-Boot-porting"><a href="#U-Boot-porting" class="headerlink" title="U-Boot porting"></a>U-Boot porting</h2><p>非常重要的一篇文章，讲述如何在porting一个新板子。<br><a href="https://elinux.org/images/2/2a/Schulz-how-to-support-new-board-u-boot-linux.pdf" target="_blank" rel="noopener">https://elinux.org/images/2/2a/Schulz-how-to-support-new-board-u-boot-linux.pdf</a></p><hr><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p>C运行环境：<br><a href="http://microchipdeveloper.com/tls2101:c-runtime-environment" target="_blank" rel="noopener">http://microchipdeveloper.com/tls2101:c-runtime-environment</a><br><a href="http://web.cs.ucdavis.edu/~pandey/Teaching/ECS142/Lects/runtime.pdf" target="_blank" rel="noopener">http://web.cs.ucdavis.edu/~pandey/Teaching/ECS142/Lects/runtime.pdf</a></p></li><li><p>位置无关原理：<br><a href="https://blog.csdn.net/ooonebook/article/details/53047992" target="_blank" rel="noopener">https://blog.csdn.net/ooonebook/article/details/53047992</a><br><a href="https://blog.csdn.net/skyflying2012/article/details/37660265" target="_blank" rel="noopener">https://blog.csdn.net/skyflying2012/article/details/37660265</a><br><a href="https://github.com/lentinj/u-boot/blob/master/doc/README.arm-relocation" target="_blank" rel="noopener">https://github.com/lentinj/u-boot/blob/master/doc/README.arm-relocation</a></p></li><li><p>u-boot启动命令：<br><a href="https://blog.csdn.net/ooonebook/article/details/53495021" target="_blank" rel="noopener">https://blog.csdn.net/ooonebook/article/details/53495021</a><br><a href="https://blog.csdn.net/ooonebook/article/details/53164198" target="_blank" rel="noopener">https://blog.csdn.net/ooonebook/article/details/53164198</a><br><a href="http://www.wowotech.net/x_project/bubblegum_uboot_booti.html" target="_blank" rel="noopener">http://www.wowotech.net/x_project/bubblegum_uboot_booti.html</a></p></li><li><p>整体参考资料：<br><a href="http://www.wowotech.net/u-boot/boot_flow_1.html" target="_blank" rel="noopener">http://www.wowotech.net/u-boot/boot_flow_1.html</a><br><a href="http://www.wowotech.net/u-boot/boot_flow_2.html" target="_blank" rel="noopener">http://www.wowotech.net/u-boot/boot_flow_2.html</a><br><a href="http://www.wowotech.net/u-boot/fit_image_overview.html" target="_blank" rel="noopener">http://www.wowotech.net/u-boot/fit_image_overview.html</a><br><a href="https://blog.csdn.net/ooonebook/article/details/52957395" target="_blank" rel="noopener">https://blog.csdn.net/ooonebook/article/details/52957395</a></p></li></ul></div><div><div class="my_post_copyright"><script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script><script src="https://cdn.bootcss.com/jquery/2.0.0/jquery.min.js"></script><script src="https://unpkg.com/sweetalert/dist/sweetalert.min.js"></script><p><span>Title:</span><a href="/146db8db/">u-boot启动流程</a></p><p><span>Author:</span><a href="/" title="Visit Victor Huang blog">Victor Huang</a></p><p><span>Time:</span>2019-07-03 / 21:07</p><p><span>Link:</span><a href="/146db8db/" title="u-boot启动流程">http://wowothink.com/146db8db/</a> <span class="copy-path" title="click to copy link"><i class="fa fa-clipboard" data-clipboard-text="http://wowothink.com/146db8db/" aria-label="copy link success"></i></span></p><p><span>License:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)</a></p></div><script>var clipboard=new Clipboard(".fa-clipboard");$(".fa-clipboard").click(function(){clipboard.on("success",function(){swal({title:"",text:"copy link success",icon:"success",showConfirmButton:!0})})})</script></div><footer class="post-footer"><div class="post-tags"><a href="/tags/u-boot/" rel="tag"><i class="fa fa-tag"></i> u-boot</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/8b524cfd/" rel="next" title="Android传递宏给uboot或kernel"><i class="fa fa-chevron-left"></i> Android传递宏给uboot或kernel</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/97742f2b/" rel="prev" title="Linux 性能测试工具">Linux 性能测试工具 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"></div></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">站点概览</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/images/boy2.jpg" alt="Victor Huang"><p class="site-author-name" itemprop="name">Victor Huang</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">81</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">18</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">17</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="mailto:hsq_encourage@163.com" target="_blank" title="E-Mail"><i class="fa fa-fw fa-envelope"></i>E-Mail</a> </span><span class="links-of-author-item"><a href="https://blog.csdn.net/encourage2011" target="_blank" title="CSDN博客"><i class="fa fa-fw fa-crosshairs"></i>CSDN博客</a></span></div></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#u-boot入口"><span class="nav-number">2.</span> <span class="nav-text">u-boot入口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#main简要说明"><span class="nav-number">3.</span> <span class="nav-text">_main简要说明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#main的详细流程如下："><span class="nav-number">4.</span> <span class="nav-text">_main的详细流程如下：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#board-init-f-函数"><span class="nav-number">5.</span> <span class="nav-text">board_init_f()函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#u-boot-relocate"><span class="nav-number">6.</span> <span class="nav-text">u-boot relocate</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#reserve空间"><span class="nav-number">6.1.</span> <span class="nav-text">reserve空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#relocate-u-boot"><span class="nav-number">6.2.</span> <span class="nav-text">relocate u-boot</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#board-init-r函数"><span class="nav-number">7.</span> <span class="nav-text">board_init_r函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#main-loop"><span class="nav-number">8.</span> <span class="nav-text">main_loop()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Boot-Linux"><span class="nav-number">9.</span> <span class="nav-text">Boot Linux</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#U-Boot-porting"><span class="nav-number">10.</span> <span class="nav-text">U-Boot porting</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考资料"><span class="nav-number">11.</span> <span class="nav-text">参考资料</span></a></li></ol></div></div></section><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span id="scrollpercent"><span>0</span>%</span></div><script type="text/javascript" charset="utf-8" src="/js/tagcloud.js"></script><script type="text/javascript" charset="utf-8" src="/js/tagcanvas.js"></script><div class="widget-wrap"><div id="myCanvasContainer" class="widget tagcloud"><canvas width="200" height="200" id="resCanvas"><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android编译相关/">Android编译相关</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux-Kernel/">Linux Kernel</a><span class="tag-list-count">10</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux-Kernel优化/">Linux Kernel优化</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux-USB/">Linux USB</a><span class="tag-list-count">10</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux-driver/">Linux driver</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux-性能测试/">Linux 性能测试</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python脚本/">Python脚本</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/eMMC/">eMMC</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/i-MX6/">i.MX6</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/i-MX8/">i.MX8</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/u-boot/">u-boot</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ubuntu工具/">ubuntu工具</a><span class="tag-list-count">11</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/在家学习嵌入式/">在家学习嵌入式</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/备忘记录/">备忘记录</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/碰到的问题/">碰到的问题</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网站记录/">网站记录</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/调试工具/">调试工具</a><span class="tag-list-count">2</span></li></ul></canvas></div></div></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2020</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">Victor Huang</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-area-chart"></i> </span><span class="post-meta-item-text">Site words total count&#58;</span> <span title="Site words total count">104.7k</span></div></div></footer></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script><script type="text/javascript">function proceedsearch(){$("body").append('<div class="search-popup-overlay local-search-pop-overlay"></div>').css("overflow","hidden"),$(".search-popup-overlay").click(onPopupClose),$(".popup").toggle();var t=$("#local-search-input");t.attr("autocapitalize","none"),t.attr("autocorrect","off"),t.focus()}var isfetched=!1,isXml=!0,search_path="./public/search.xml";0===search_path.length?search_path="search.xml":/json$/i.test(search_path)&&(isXml=!1);var path="/"+search_path,onPopupClose=function(t){$(".popup").hide(),$("#local-search-input").val(""),$(".search-result-list").remove(),$("#no-result").remove(),$(".local-search-pop-overlay").remove(),$("body").css("overflow","")},searchFunc=function(t,e,o){"use strict";$("body").append('<div class="search-popup-overlay local-search-pop-overlay"><div id="search-loading-icon"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div>').css("overflow","hidden"),$("#search-loading-icon").css("margin","20% auto 0 auto").css("text-align","center"),$.ajax({url:t,dataType:isXml?"xml":"json",async:!0,success:function(t){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var n=isXml?$("entry",t).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get():t,r=document.getElementById(e),s=document.getElementById(o),a=function(){var t=r.value.trim().toLowerCase(),e=t.split(/[\s\-]+/);e.length>1&&e.push(t);var o=[];if(t.length>0&&n.forEach(function(n){function r(e,o,n,r){for(var s=r[r.length-1],a=s.position,i=s.word,l=[],h=0;a+i.length<=n&&0!=r.length;){i===t&&h++,l.push({position:a,length:i.length});var p=a+i.length;for(r.pop();0!=r.length&&(s=r[r.length-1],a=s.position,i=s.word,p>a);)r.pop()}return c+=h,{hits:l,start:o,end:n,searchTextCount:h}}function s(t,e){var o="",n=e.start;return e.hits.forEach(function(e){o+=t.substring(n,e.position);var r=e.position+e.length;o+='<b class="search-keyword">'+t.substring(e.position,r)+"</b>",n=r}),o+=t.substring(n,e.end)}var a=!1,i=0,c=0,l=n.title.trim(),h=l.toLowerCase(),p=n.content.trim().replace(/<[^>]+>/g,""),u=p.toLowerCase(),f=decodeURIComponent(n.url),d=[],g=[];if(""!=l&&(e.forEach(function(t){function e(t,e,o){var n=t.length;if(0===n)return[];var r=0,s=[],a=[];for(o||(e=e.toLowerCase(),t=t.toLowerCase());(s=e.indexOf(t,r))>-1;)a.push({position:s,word:t}),r=s+n;return a}d=d.concat(e(t,h,!1)),g=g.concat(e(t,u,!1))}),(d.length>0||g.length>0)&&(a=!0,i=d.length+g.length)),a){[d,g].forEach(function(t){t.sort(function(t,e){return e.position!==t.position?e.position-t.position:t.word.length-e.word.length})});var v=[];0!=d.length&&v.push(r(l,0,l.length,d));for(var $=[];0!=g.length;){var C=g[g.length-1],m=C.position,x=C.word,w=m-20,y=m+80;0>w&&(w=0),y<m+x.length&&(y=m+x.length),y>p.length&&(y=p.length),$.push(r(p,w,y,g))}$.sort(function(t,e){return t.searchTextCount!==e.searchTextCount?e.searchTextCount-t.searchTextCount:t.hits.length!==e.hits.length?e.hits.length-t.hits.length:t.start-e.start});var T=parseInt("1");T>=0&&($=$.slice(0,T));var b="";b+=0!=v.length?"<li><a href='"+f+"' class='search-result-title'>"+s(l,v[0])+"</a>":"<li><a href='"+f+"' class='search-result-title'>"+l+"</a>",$.forEach(function(t){b+="<a href='"+f+'\'><p class="search-result">'+s(p,t)+"...</p></a>"}),b+="</li>",o.push({item:b,searchTextCount:c,hitCount:i,id:o.length})}}),1===e.length&&""===e[0])s.innerHTML='<div id="no-result"><i class="fa fa-search fa-5x" /></div>';else if(0===o.length)s.innerHTML='<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>';else{o.sort(function(t,e){return t.searchTextCount!==e.searchTextCount?e.searchTextCount-t.searchTextCount:t.hitCount!==e.hitCount?e.hitCount-t.hitCount:e.id-t.id});var a='<ul class="search-result-list">';o.forEach(function(t){a+=t.item}),a+="</ul>",s.innerHTML=a}};r.addEventListener("input",a),$(".local-search-pop-overlay").remove(),$("body").css("overflow",""),proceedsearch()}})};$(".popup-trigger").click(function(t){t.stopPropagation(),isfetched===!1?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(onPopupClose),$(".popup").click(function(t){t.stopPropagation()}),$(document).on("keyup",function(t){var e=27===t.which&&$(".search-popup").is(":visible");e&&onPopupClose()})</script><script>!function(){var t=document.createElement("script"),s=window.location.protocol.split(":")[0];"https"===s?t.src="https://zz.bdstatic.com/linksubmit/push.js":t.src="http://push.zhanzhang.baidu.com/push.js";var e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(t,e)}()</script><script type="text/javascript" src="/js/src/clipboard.js"></script><script type="text/javascript" src="/js/src/clipboard-use.js"></script></body></html><!-- rebuild by neat -->