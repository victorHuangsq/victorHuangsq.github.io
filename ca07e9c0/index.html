<!-- build time:Sun Aug 11 2019 14:21:21 GMT+0800 (中国标准时间) --><!DOCTYPE html><html class="theme-next pisces use-motion" lang="zh-Hans"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/images/laptop.png?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/laptop.png?v=5.1.4"><link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222"><meta name="keywords" content="Linux Kernel,"><meta name="description" content="在嵌入式开发中，出现freeze的问题很让人头疼，就是那种不发生kernel panic，什么log不输出，串口终端死掉，无法输入输出。这时候，肯定是哪里出现了死锁或者死循环，长时间占用CPU资源，导致其他进程无法运行。比如说，在底层的USB Host控制器驱动中，设置完某个控制寄存器，然后用while来检查状态寄存器的某一位是否满足条件。如果该控制器本身出现了问题，那么，将会一直卡在while中"><meta name="keywords" content="Linux Kernel"><meta property="og:type" content="article"><meta property="og:title" content="lockup watchdogs &amp; rcu stall detector"><meta property="og:url" content="http://wowothink.com/ca07e9c0/index.html"><meta property="og:site_name" content="wowothink"><meta property="og:description" content="在嵌入式开发中，出现freeze的问题很让人头疼，就是那种不发生kernel panic，什么log不输出，串口终端死掉，无法输入输出。这时候，肯定是哪里出现了死锁或者死循环，长时间占用CPU资源，导致其他进程无法运行。比如说，在底层的USB Host控制器驱动中，设置完某个控制寄存器，然后用while来检查状态寄存器的某一位是否满足条件。如果该控制器本身出现了问题，那么，将会一直卡在while中"><meta property="og:locale" content="zh-Hans"><meta property="og:updated_time" content="2019-03-17T08:23:55.046Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="lockup watchdogs &amp; rcu stall detector"><meta name="twitter:description" content="在嵌入式开发中，出现freeze的问题很让人头疼，就是那种不发生kernel panic，什么log不输出，串口终端死掉，无法输入输出。这时候，肯定是哪里出现了死锁或者死循环，长时间占用CPU资源，导致其他进程无法运行。比如说，在底层的USB Host控制器驱动中，设置完某个控制寄存器，然后用while来检查状态寄存器的某一位是否满足条件。如果该控制器本身出现了问题，那么，将会一直卡在while中"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Pisces",version:"5.1.4",sidebar:{position:"right",display:"post",offset:12,b2t:!0,scrollpercent:!0,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://wowothink.com/ca07e9c0/"><title>lockup watchdogs & rcu stall detector | wowothink</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-right page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">wowothink</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">thinking all the time</p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-folder"></i><br>归档</a></li><li class="menu-item menu-item-邮件"><a href="mailto:hsq_encourage@163.com" rel="section"><i class="menu-item-icon fa fa-fw fa-envelope"></i><br>邮件</a></li><li class="menu-item menu-item-博客"><a href="https://blog.csdn.net/encourage2011" rel="section"><i class="menu-item-icon fa fa-fw fa-crosshairs"></i><br>博客</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i> </span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"><input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://wowothink.com/ca07e9c0/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Victor Huang"><meta itemprop="description" content=""><meta itemprop="image" content="/images/boy2.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="wowothink"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">lockup watchdogs & rcu stall detector</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-20T16:11:47+08:00">2018-05-20 </time></span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Linux-Kernel/" itemprop="url" rel="index"><span itemprop="name">Linux Kernel</span></a></span></span><div class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">字数统计&#58;</span> <span title="字数统计">3,819 </span><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span title="阅读时长">18</span></div></div></header><div class="post-body" itemprop="articleBody"><p>在嵌入式开发中，出现freeze的问题很让人头疼，就是那种不发生kernel panic，什么log不输出，串口终端死掉，无法输入输出。这时候，肯定是哪里出现了死锁或者死循环，长时间占用CPU资源，导致其他进程无法运行。<br>比如说，在底层的USB Host控制器驱动中，设置完某个控制寄存器，然后用while来检查状态寄存器的某一位是否满足条件。如果该控制器本身出现了问题，那么，将会一直卡在while中无法退出，此时就会出现freeze。<br>还有，我们有时候会看到<code>watchdog/0</code>进程的CPU占用率非常高，此时也有可能是哪个循环语句占用太长的时间导致的。<br>以下的内容参照：<a href="http://blog.csdn.net/luckyapple1028/article/details/51932414" target="_blank" rel="noopener">http://blog.csdn.net/luckyapple1028/article/details/51932414</a><br>这篇文章帮助很大，在此表示感谢。<a id="more"></a></p><hr><h1 id="lockup-watchdogs-detector简介"><a href="#lockup-watchdogs-detector简介" class="headerlink" title="lockup watchdogs detector简介"></a>lockup watchdogs detector简介</h1><p>关于<code>lockup watchdogs detector</code>，可以参照：<code>Documentation/lockup-watchdogs.txt</code>文章。Linux Kernel中有个看门狗，用于检测死锁问题，包括<code>softlockup</code>和<code>hardlockup</code>。<br><code>softlockup</code>的介绍如下：</p><blockquote><p>A <code>softlockup</code> is defined as a bug that causes the kernel to loop in kernel mode for more than <font color="red">20 seconds</font> (see <code>Implementation</code> below fordetails), <font color="red">without giving other tasks a chance to run</font>.<br>The current stack trace is displayed upon detection and, by default, the system will stay locked up. Alternatively, the kernel can be configured to panic;<br>a sysctl, <code>kernel.softlockup_panic</code>, a kernel parameter,<code>softlockup_panic</code> (see <code>Documentation/kernel-parameters.txt</code> for details), and a compile option, <code>BOOTPARAM_HARDLOCKUP_PANIC</code>, are provided for this.</p></blockquote><p><code>hardlockup</code>介绍如下：</p><blockquote><p>A <code>hardlockup</code> is defined as a bug that causes the CPU to loop in kernel mode for more than <font color="red">10 seconds</font> (see <code>Implementation</code> below fordetails), <font color="red">without letting other interrupts have a chance to run</font>.<br>Similarly to the softlockup case, the current stack trace is displayedupon detection and the system will stay locked up unless the default behavior is changed, which can be done through a compile time knob,<br><code>BOOTPARAM_HARDLOCKUP_PANIC</code>, and a kernel parameter, <code>nmi_watchdog</code> (see <code>Documentation/kernel-parameters.txt</code> for details).</p></blockquote><p><code>softlockup</code>是进程上下文出现的死锁，<code>hardlockup</code>是中断上下文出现的死锁。</p><blockquote><p><code>R状态死锁</code>指的是某一任务一直处于TASK_RUNNING态且<code>一直占用着CPU</code>，从而导致其他进程得不到调度而饿死的情况。一般情况下，R状态死锁较可能是由于程序出现死循环导致的，可以出现在内核态的进程上下文中（内核配置为非抢占式，soft lockup），也可以出现在中断上下文中的中断处理程序中（hard lockup）。<br>异常的程序一直运行，CPU无法调度到其他的任务运行，对于单CPU的设备，则直接的表现就是“死机”。这种死锁现象较难定位，内核也同样提供了一种检测手段来检测这种死锁并向用户发出告警–<code>LOCKUP_DETECTOR</code>，它可支持监测进程上下文和中断上下文中的R状态死锁（<code>SOFTLOCKUP_DETECTOR</code>和<code>HARDLOCKUP_DETECTOR</code>），由于<code>HARDLOCKUP_DETECTOR</code>需要<code>nmi中断</code>的支持且目前的arm32环境并不支持，本文仅分析其中<code>SOFTLOCKUP_DETECTOR</code>中的原理及实现方式，并给出一个示例。</p></blockquote><hr><h1 id="lockup-watchdogs-detectors实现机制"><a href="#lockup-watchdogs-detectors实现机制" class="headerlink" title="lockup watchdogs detectors实现机制"></a>lockup watchdogs detectors实现机制</h1><p>该机制是基于<code>hrtimer</code>和<code>perf</code>子系统，介绍如下：</p><blockquote><p><font color="red">A periodic hrtimer runs to generate interrupts and kick the watchdog task</font>. An NMI perf event is generated every <code>watchdog_thresh</code>(compile-time initialized to 10 and configurable through sysctl of the same name) seconds to check for hardlockups. If any CPU in the system does not receive any hrtimer interrupt during that time the <code>hardlockup detector</code> (the handler for the NMI perf event) will generate a kernel warning or call panic, depending on theconfiguration.</p><p><font color="red">The watchdog task is a high priority kernel thread that updates a timestamp every time it is scheduled</font>. If that timestamp is not updatedfor <code>2*watchdog_thresh</code> seconds (the softlockup threshold) the <code>softlockup detector</code> (coded inside the hrtimer callback function)will dump useful debug information to the system log, after which it will call panic if it was instructed to do so or resume execution of other kernel code.</p></blockquote><p><code>lockup detector机制</code>在内核代码的<code>kernel/watchdog.c</code>中实现，本文以Linux 4.1.15版本源码为例进行分析。首先了解其背后的设计原理：</p><font color="red">利用进程上下文、中断、nmi中断的不同优先级实现死锁监测。它们3者的优先级关系为“进程上下文 &lt; 中断 &lt; nmi中断”，其中进程上下文优先级最低，可通过中断来进行监测进程的运行状态，nmi中断的优先级最高，它是一种不可屏蔽的中断，在中断上下文中发生死锁时，nmi中断处理也可正常进入，因此可用来监测中断中的死锁。</font><p>关于这部分的流程分析，我也不是很懂。我只想知道，多久喂一次狗？多久会超时？超时之后会做怎样的动作？<br>更具体的流程，请参照：<br><a href="http://blog.csdn.net/luckyapple1028/article/details/51932414" target="_blank" rel="noopener">http://blog.csdn.net/luckyapple1028/article/details/51932414</a></p><hr><h1 id="lockup-watchdogs-detectors常见参数"><a href="#lockup-watchdogs-detectors常见参数" class="headerlink" title="lockup watchdogs detectors常见参数"></a>lockup watchdogs detectors常见参数</h1><p>主要参数在<code>&lt;Kernel_Dir&gt;/Kernel/watchdog.c</code>文件中设定。</p><h2 id="watchdog-thresh"><a href="#watchdog-thresh" class="headerlink" title="watchdog_thresh"></a>watchdog_thresh</h2><p>设置看门狗超时时间，hard lockup的时间默认是10s，soft lockup的时间是20s，该值可通过<code>/proc/sys/kernel/watchdog_thresh</code>去配置。</p><h2 id="sample-period"><a href="#sample-period" class="headerlink" title="sample_period"></a>sample_period</h2><p>该值定义喂狗时间，默认是<code>watchdog_thresh</code>的五分一。<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">set_sample_period</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * convert watchdog_thresh from seconds to ns</span></span><br><span class="line"><span class="comment">	 * the divide by 5 is to give hrtimer several chances (two</span></span><br><span class="line"><span class="comment">	 * or three with the current relation between the soft</span></span><br><span class="line"><span class="comment">	 * and hard thresholds) to increment before the</span></span><br><span class="line"><span class="comment">	 * hardlockup detector generates a warning</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	sample_period = get_softlockup_thresh() * ((u64)NSEC_PER_SEC / <span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="watchdog-timer-fn"><a href="#watchdog-timer-fn" class="headerlink" title="watchdog_timer_fn()"></a>watchdog_timer_fn()</h2><p>看门狗超时执行的函数，在这个函数里，会打印堆栈信息，用来判断是谁lockup了。<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># insmod watchdog_test.ko                               </span></span><br><span class="line">[ <span class="number">2977.578690</span>] in watchdog_test_init, line = <span class="number">16</span> starttttt</span><br><span class="line">[ <span class="number">3004.000899</span>] BUG: soft lockup - CPU#<span class="number">0</span> stuck <span class="keyword">for</span> <span class="number">22</span>s! [insmod:<span class="number">391</span>]</span><br><span class="line">[ <span class="number">3004.006866</span>] Modules linked in: watchdog_test(+) wlan(O) ehci_hcd usb_f_ss_lb usb_f_ncm u_ether libcompo)</span><br><span class="line">[ <span class="number">3004.025606</span>] </span><br><span class="line">[ <span class="number">3004.027092</span>] CPU: <span class="number">0</span> PID: <span class="number">391</span> Comm: insmod Tainted: P           O <span class="number">3.14</span><span class="number">.19</span> #<span class="number">1</span></span><br><span class="line">[ <span class="number">3004.033930</span>] task: cd0ecc00 ti: ce1d8000 task.ti: ce1d8000</span><br><span class="line">[ <span class="number">3004.039304</span>] PC is at watchdog_test_init+<span class="number">0x1c</span>/<span class="number">0x20</span> [watchdog_test]</span><br><span class="line">[ <span class="number">3004.045364</span>] LR is at watchdog_test_init+<span class="number">0x1c</span>/<span class="number">0x20</span> [watchdog_test]</span><br><span class="line">[ <span class="number">3004.051428</span>] pc : [&lt;bf44b01c&gt;]    lr : [&lt;bf44b01c&gt;]    psr: <span class="number">600f</span>0013</span><br><span class="line">[ <span class="number">3004.051428</span>] sp : ce1d9e20  ip : <span class="number">00000000</span>  fp : bf44b0dc</span><br><span class="line">[ <span class="number">3004.062845</span>] r10: bf44b000  r9 : <span class="number">00000000</span>  r8 : ce1d8028</span><br><span class="line">[ <span class="number">3004.068040</span>] r7 : <span class="number">00000001</span>  r6 : bf44b094  r5 : bf44b0a0  r4 : ce1d9f58</span><br><span class="line">[ <span class="number">3004.074529</span>] r3 : <span class="number">00000752</span>  r2 : <span class="number">1374</span>d000  r1 : d3d6e340  r0 : <span class="number">0000002</span>a</span><br><span class="line">[ <span class="number">3004.081020</span>] Flags: nZCv  IRQs on  FIQs on  Mode SVC_32  ISA ARM  Segment user</span><br><span class="line">[ <span class="number">3004.088110</span>] Control: <span class="number">10</span>c53c7d  Table: b34e404a  DAC: <span class="number">00000015</span></span><br><span class="line">[ <span class="number">3004.093823</span>] CPU: <span class="number">0</span> PID: <span class="number">391</span> Comm: insmod Tainted: P           O <span class="number">3.14</span><span class="number">.19</span> #<span class="number">1</span></span><br><span class="line">[ <span class="number">3004.100689</span>] [&lt;c0015f68&gt;] (unwind_backtrace) from [&lt;c0012288&gt;] (show_stack+<span class="number">0x10</span>/<span class="number">0x14</span>)</span><br><span class="line">[ <span class="number">3004.108406</span>] [&lt;c0012288&gt;] (show_stack) from [&lt;c047dc20&gt;] (dump_stack+<span class="number">0x80</span>/<span class="number">0x90</span>)</span><br><span class="line">[ <span class="number">3004.115600</span>] [&lt;c047dc20&gt;] (dump_stack) from [&lt;c0082e08&gt;] (watchdog_timer_fn+<span class="number">0x144</span>/<span class="number">0x17c</span>)</span><br><span class="line">[ <span class="number">3004.123573</span>] [&lt;c0082e08&gt;] (watchdog_timer_fn) from [&lt;c003c3dc&gt;] (__run_hrtimer.isra<span class="number">.32</span>+<span class="number">0x54</span>/<span class="number">0xe4</span>)</span><br><span class="line">[ <span class="number">3004.132321</span>] [&lt;c003c3dc&gt;] (__run_hrtimer.isra<span class="number">.32</span>) from [&lt;c003cca0&gt;] (hrtimer_interrupt+<span class="number">0x114</span>/<span class="number">0x2c8</span>)</span><br><span class="line">[ <span class="number">3004.141236</span>] [&lt;c003cca0&gt;] (hrtimer_interrupt) from [&lt;c0014b90&gt;] (twd_handler+<span class="number">0x34</span>/<span class="number">0x44</span>)</span><br><span class="line">[ <span class="number">3004.149119</span>] [&lt;c0014b90&gt;] (twd_handler) from [&lt;c005f650&gt;] (handle_percpu_devid_irq+<span class="number">0x6c</span>/<span class="number">0x84</span>)</span><br><span class="line">[ <span class="number">3004.157514</span>] [&lt;c005f650&gt;] (handle_percpu_devid_irq) from [&lt;c005bb80&gt;] (generic_handle_irq+<span class="number">0x2c</span>/<span class="number">0x3c</span>)</span><br><span class="line">[ <span class="number">3004.166517</span>] [&lt;c005bb80&gt;] (generic_handle_irq) from [&lt;c000fbf4&gt;] (handle_IRQ+<span class="number">0x74</span>/<span class="number">0xe8</span>)</span><br><span class="line">[ <span class="number">3004.174396</span>] [&lt;c000fbf4&gt;] (handle_IRQ) from [&lt;c0008554&gt;] (gic_handle_irq+<span class="number">0x2c</span>/<span class="number">0x5c</span>)</span><br><span class="line">[ <span class="number">3004.181930</span>] [&lt;c0008554&gt;] (gic_handle_irq) from [&lt;c0012dc0&gt;] (__irq_svc+<span class="number">0x40</span>/<span class="number">0x50</span>)</span><br><span class="line">[ <span class="number">3004.189371</span>] Exception <span class="built_in">stack</span>(<span class="number">0xce1d9dd8</span> to <span class="number">0xce1d9e20</span>)</span><br><span class="line">[ <span class="number">3004.194392</span>] <span class="number">9</span>dc0:                                                       <span class="number">0000002</span>a d3d6e340</span><br><span class="line">[ <span class="number">3004.202526</span>] <span class="number">9</span>de0: <span class="number">1374</span>d000 <span class="number">00000752</span> ce1d9f58 bf44b0a0 bf44b094 <span class="number">00000001</span> ce1d8028 <span class="number">00000000</span></span><br><span class="line">[ <span class="number">3004.210664</span>] <span class="number">9e00</span>: bf44b000 bf44b0dc <span class="number">00000000</span> ce1d9e20 bf44b01c bf44b01c <span class="number">600f</span>0013 ffffffff</span><br><span class="line">[ <span class="number">3004.218801</span>] [&lt;c0012dc0&gt;] (__irq_svc) from [&lt;bf44b01c&gt;] (watchdog_test_init+<span class="number">0x1c</span>/<span class="number">0x20</span> [watchdog_test])</span><br><span class="line">[ <span class="number">3004.227984</span>] [&lt;bf44b01c&gt;] (watchdog_test_init [watchdog_test]) from [&lt;c0008908&gt;] (do_one_initcall+<span class="number">0xd4</span>/<span class="number">0x17c</span>)</span><br><span class="line">[ <span class="number">3004.237766</span>] [&lt;c0008908&gt;] (do_one_initcall) from [&lt;c00765ec&gt;] (load_module+<span class="number">0x1bec</span>/<span class="number">0x2140</span>)</span><br><span class="line">[ <span class="number">3004.245815</span>] [&lt;c00765ec&gt;] (load_module) from [&lt;c0076be8&gt;] (SyS_init_module+<span class="number">0xa8</span>/<span class="number">0x110</span>)</span><br><span class="line">[ <span class="number">3004.253608</span>] [&lt;c0076be8&gt;] (SyS_init_module) from [&lt;c000eca0&gt;] (ret_fast_syscall+<span class="number">0x0</span>/<span class="number">0x30</span>)</span><br></pre></td></tr></table></figure><p></p><p>注意，在做上述测试<code>softlock watchdog</code>的时候，要确保<code>rcu stall detector</code>机制是关闭的或者设置<code>rcu stall detector</code>的超时更长，否则会使<code>rcu stall detector</code>先检测出来死锁。<br>设置时间要大于<code>softlock watchdog_thresh</code>的值，方法如下：<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># echo 30 &gt; /sys/module/rcupdate/parameters/rcu_cpu_stall_timeout</span></span><br></pre></td></tr></table></figure><p></p><p>或者将<code>rcu_sched</code>的<code>stall warning</code>输出关闭，方法如下：<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># echo 1 &gt; /sys/module/rcupdate/parameters/rcu_cpu_stall_suppress</span></span><br></pre></td></tr></table></figure><p></p><p>这里的堆栈信息，可以使用反汇编技术，确定是在哪一条语句出现问题的。<br>我这里使用的测试程序如下：<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">watchdog_test_init</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">3</span>;</span><br><span class="line">    printk(<span class="string">"in %s, line = %d starttttt\n"</span>, __func__, __LINE__);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//mdelay(3000);</span></span><br><span class="line"></span><br><span class="line">    printk(<span class="string">"in %s, line = %d endddddddddd\n"</span>, __func__, __LINE__);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">watchdog_test_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(watchdog_test_init);</span><br><span class="line">module_exit(watchdog_test_exit);</span><br><span class="line"></span><br><span class="line">MODULE_AUTHOR(<span class="string">"XXX Project"</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">"watchdog test driver"</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br></pre></td></tr></table></figure><p></p><p>如果有打开<code>softlockup_panic</code>参数，那么还会调用<code>panic(&quot;softlockup: hung tasks&quot;);</code>以此输出panic信息供调试。</p><h2 id="softlockup-panic"><a href="#softlockup-panic" class="headerlink" title="softlockup_panic"></a>softlockup_panic</h2><p>该参数用来选择当看门狗超时的时候，是否触发panic。有以下两种方式来设置该值。非0，表示输出panic信息。该值默认为0，<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> __read_mostly softlockup_panic =</span><br><span class="line">			CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE;</span><br></pre></td></tr></table></figure><p></p><p>第1种方法通过在<code>defconfig</code>中设置<code>CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC=y</code>即可，因为<code>BOOTPARAM_SOFTLOCKUP_PANIC_VALUE</code>的值依赖于<code>CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE</code>.<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">config BOOTPARAM_SOFTLOCKUP_PANIC_VALUE</span><br><span class="line">        <span class="keyword">int</span></span><br><span class="line">        depends on LOCKUP_DETECTOR</span><br><span class="line">        range <span class="number">0</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">default</span> <span class="number">0</span> <span class="keyword">if</span> !BOOTPARAM_SOFTLOCKUP_PANIC</span><br><span class="line">        <span class="keyword">default</span> <span class="number">1</span> <span class="keyword">if</span> BOOTPARAM_SOFTLOCKUP_PANIC</span><br></pre></td></tr></table></figure><p></p><p>第2种方法是在启动命令中加入<code>softlockup_panic=</code>的参数进行选择。<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">softlockup_panic_setup</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	softlockup_panic = simple_strtoul(str, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">__setup(<span class="string">"softlockup_panic="</span>, softlockup_panic_setup);</span><br></pre></td></tr></table></figure><p></p><h2 id="watchdog-user-enabled"><a href="#watchdog-user-enabled" class="headerlink" title="watchdog_user_enabled"></a>watchdog_user_enabled</h2><p>是否打开<code>lockup watchdogs</code>功能，默认为1，可通过<code>/proc/sys/kernel/watchdog</code>去设置，对应的接口函数为：<code>proc_dowatchdog()</code>。</p><hr><h1 id="watchdog-0-进程CPU占用率高调试方法"><a href="#watchdog-0-进程CPU占用率高调试方法" class="headerlink" title="watchdog/0 进程CPU占用率高调试方法"></a>watchdog/0 进程CPU占用率高调试方法</h1><p>有时候会发现<code>watchdog/0</code>(这里的0表示CPU0，下面以CPU0为例)或者其他CPU核上的<code>watchdog</code>进程的CPU占用率很高，有可能是内核中某个驱动长时间占用CPU，但是没有被锁住触发到<code>lockup watchdog detector</code>，所以就表现为<code>watchdog/0</code>的CPU占用率非常高。<br>比如说在上面的<code>watchdog_test.c</code>的驱动程序中，将<code>while(1)</code>语句改成<code>mdelay(6000)</code>，延时6s，加载该驱动后，打印出来的<code>watchdog/0</code>CPU占用率非常高。<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">xxx_project:/data <span class="meta"># top -m 5 &amp;</span></span><br><span class="line"></span><br><span class="line">User <span class="number">2</span>%, System <span class="number">7</span>%, IOW <span class="number">0</span>%, IRQ <span class="number">4</span>%</span><br><span class="line">User <span class="number">8</span> + Nice <span class="number">0</span> + Sys <span class="number">21</span> + Idle <span class="number">253</span> + IOW <span class="number">0</span> + IRQ <span class="number">12</span> + SIRQ <span class="number">2</span> = <span class="number">296</span></span><br><span class="line"></span><br><span class="line">  PID   PR   NI CPU% S  #THR     VSS     RSS PCY UID      Name</span><br><span class="line">   <span class="number">57</span>   <span class="number">20</span>    <span class="number">0</span>   <span class="number">2</span>% S    <span class="number">18</span> <span class="number">108060</span>K   <span class="number">2584</span>K  fg <span class="number">0</span>        /bin/klogd</span><br><span class="line">   <span class="number">66</span>   <span class="number">20</span>    <span class="number">0</span>   <span class="number">1</span>% S    <span class="number">12</span>  <span class="number">75152</span>K   <span class="number">2400</span>K  fg <span class="number">0</span>        /system/bin/testmanager</span><br><span class="line">   <span class="number">77</span>   <span class="number">20</span>    <span class="number">0</span>   <span class="number">1</span>% S     <span class="number">9</span>  <span class="number">49408</span>K   <span class="number">2120</span>K     <span class="number">0</span>        /system/bin/ilog</span><br><span class="line">  <span class="number">440</span>   <span class="number">20</span>    <span class="number">0</span>   <span class="number">1</span>% R     <span class="number">2</span>  <span class="number">12388</span>K   <span class="number">1176</span>K     <span class="number">0</span>        top</span><br><span class="line">   <span class="number">67</span>   <span class="number">20</span>    <span class="number">0</span>   <span class="number">1</span>% S    <span class="number">27</span> <span class="number">306280</span>K   <span class="number">4596</span>K  fg <span class="number">0</span>        /system/bin/updatemanager</span><br><span class="line">xxx_project:/data # insmod watchdog_test.ko                               </span><br><span class="line">[  <span class="number">145.431829</span>] in watchdog_test_init, line = <span class="number">12</span> starttttt</span><br><span class="line">[  <span class="number">151.504804</span>] in watchdog_test_init, line = <span class="number">16</span> endddddddddd</span><br><span class="line">xxx_project:/data # </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">User <span class="number">0</span>%, System <span class="number">86</span>%, IOW <span class="number">0</span>%, IRQ <span class="number">1</span>%</span><br><span class="line">User <span class="number">4</span> + Nice <span class="number">0</span> + Sys <span class="number">612</span> + Idle <span class="number">81</span> + IOW <span class="number">0</span> + IRQ <span class="number">12</span> + SIRQ <span class="number">1</span> = <span class="number">710</span></span><br><span class="line"></span><br><span class="line">  PID   PR   NI CPU% S  #THR     VSS     RSS PCY UID      Name</span><br><span class="line"><span class="number">10</span> <span class="number">-100</span>    <span class="number">0</span>  <span class="number">84</span>% S     <span class="number">1</span>      <span class="number">0</span>K      <span class="number">0</span>K     <span class="number">0</span>        watchdog/<span class="number">0</span></span><br><span class="line">  <span class="number">440</span>   <span class="number">20</span>    <span class="number">0</span>   <span class="number">0</span>% R     <span class="number">2</span>  <span class="number">12676</span>K   <span class="number">1368</span>K     <span class="number">0</span>        top</span><br><span class="line">   <span class="number">57</span>   <span class="number">20</span>    <span class="number">0</span>   <span class="number">0</span>% S    <span class="number">18</span> <span class="number">108060</span>K   <span class="number">2584</span>K  fg <span class="number">0</span>        /bin/klogd</span><br><span class="line">    <span class="number">7</span>   <span class="number">20</span>    <span class="number">0</span>   <span class="number">0</span>% S     <span class="number">1</span>      <span class="number">0</span>K      <span class="number">0</span>K     <span class="number">0</span>        rcu_sched</span><br><span class="line">   <span class="number">60</span>   <span class="number">20</span>    <span class="number">0</span>   <span class="number">0</span>% S    <span class="number">13</span>  <span class="number">70220</span>K   <span class="number">3712</span>K  fg <span class="number">0</span>        /system/bin/settingmanager</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">User <span class="number">6</span>%, System <span class="number">14</span>%, IOW <span class="number">0</span>%, IRQ <span class="number">6</span>%</span><br><span class="line">User <span class="number">12</span> + Nice <span class="number">0</span> + Sys <span class="number">25</span> + Idle <span class="number">123</span> + IOW <span class="number">0</span> + IRQ <span class="number">11</span> + SIRQ <span class="number">1</span> = <span class="number">172</span></span><br><span class="line"></span><br><span class="line">  PID   PR   NI CPU% S  #THR     VSS     RSS PCY UID      Name</span><br><span class="line">   <span class="number">57</span>   <span class="number">20</span>    <span class="number">0</span>   <span class="number">4</span>% S    <span class="number">18</span> <span class="number">108060</span>K   <span class="number">2584</span>K  fg <span class="number">0</span>        /bin/klogd</span><br><span class="line">  <span class="number">440</span>   <span class="number">20</span>    <span class="number">0</span>   <span class="number">2</span>% R     <span class="number">2</span>  <span class="number">12676</span>K   <span class="number">1368</span>K     <span class="number">0</span>        top</span><br><span class="line">   <span class="number">66</span>   <span class="number">20</span>    <span class="number">0</span>   <span class="number">2</span>% S    <span class="number">12</span>  <span class="number">75152</span>K   <span class="number">2400</span>K  fg <span class="number">0</span>        /system/bin/testmanager</span><br><span class="line">   <span class="number">67</span>   <span class="number">20</span>    <span class="number">0</span>   <span class="number">2</span>% S    <span class="number">27</span> <span class="number">306280</span>K   <span class="number">4596</span>K  fg <span class="number">0</span>        /system/bin/updatemanager</span><br><span class="line">   <span class="number">77</span>   <span class="number">20</span>    <span class="number">0</span>   <span class="number">1</span>% S     <span class="number">9</span>  <span class="number">49408</span>K   <span class="number">2120</span>K     <span class="number">0</span>        /system/bin/ilog</span><br></pre></td></tr></table></figure><p></p><p>上面只能看到<code>watchdog</code>的CPU占用率高的情况，没有看到更多的信息，不好确定驱动中的哪里有长时间占用CPU的情况。<br>如果要调试这种情况，我能想到将看门狗的触发时间<code>watchdog_thresh</code>设置短一点，刚好让其触发超时。比如说我这里将<code>watchdog_thresh</code>设置为2，也就是<code>softlock</code>的看门狗时间为4s，小于测试代码中的6s，看其是否能输出调试信息。<br>测试下来，这种方法是可行的。当然，仅限于死锁时间大于4s的情况，除非自己修改驱动代码。</p><hr><h1 id="rcu-stall-detector简介"><a href="#rcu-stall-detector简介" class="headerlink" title="rcu stall detector简介"></a>rcu stall detector简介</h1><p>在上面验证<code>lockup watchdogs detector</code>机制，加载<code>watchdog_test.ko</code>驱动之前，要先将<code>rcu_cpu_stall_timeout</code>的时间设置比<code>2*watchdog_thresh</code>长，否则加载<code>watchdog_test.ko</code>之后，出现的log是<code>rcu cpu stall</code>相关的log，log如下：<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[  <span class="number">208.383733</span>] in watchdog_test_init, line = <span class="number">16</span> starttttt</span><br><span class="line">[  <span class="number">229.389303</span>] INFO: rcu_sched detected stalls on CPUs/tasks: &#123;&#125; (detected by <span class="number">0</span>, t=<span class="number">5252</span> jiffies, g=<span class="number">51235</span>, c=<span class="number">51234</span>, q=<span class="number">13</span>)</span><br><span class="line">[  <span class="number">229.399881</span>] INFO: Stall ended before state dump start</span><br></pre></td></tr></table></figure><p></p><p>关于<code>RCU stall detector</code>的详细内容，可以参照:<code>&lt;Kernel_Dir&gt;/Documentation/RCU/stallwarn.txt</code>文件，里面分别讲了什么情况下会有<code>RCU CPU Stall Warnings</code>，如何修改<code>RCU CPU Stall Detector</code>的参数，以及如何去解析该warnings。</p><p>下内容转自下面几篇文章，关于RCU的内容不是很熟悉，以后要专门学习一下。<br><a href="https://www.kernel.org/doc/Documentation/RCU/stallwarn.txt" target="_blank" rel="noopener">https://www.kernel.org/doc/Documentation/RCU/stallwarn.txt</a><br><a href="http://blog.csdn.net/wdsfup/article/details/76087670" target="_blank" rel="noopener">http://blog.csdn.net/wdsfup/article/details/76087670</a><br><a href="https://www.ibm.com/developerworks/cn/linux/l-rcu/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/linux/l-rcu/</a><br><a href="https://lwn.net/Articles/301910/" target="_blank" rel="noopener">https://lwn.net/Articles/301910/</a></p><h2 id="什么情况下触发rcu-cpu-stall-warning"><a href="#什么情况下触发rcu-cpu-stall-warning" class="headerlink" title="什么情况下触发rcu cpu stall warning"></a>什么情况下触发rcu cpu stall warning</h2><p>RCU是基于其原理命名的，<code>Read-Copy Update</code>：</p><ul><li>[Read]指的是对于被RCU保护的共享数据，reader可以直接访问，不需要获得任何锁；</li><li>[Copy Update]指的是writer修改数据前首先拷贝一个副本，然后在副本上进行修改，修改完毕后向reclaimer(垃圾回收器)注册一个回调函数(callback)，在适当的时机完成真正的修改操作：把原数据的指针重新指向新的被修改的数据，这里所说的适当的时机就是当既有的reader全都退出临界区的时候，而等待恰当时机的过程被称为<code>grace period</code>。</li><li>在RCU机制中，writer不需要和reader竞争任何锁，只在有多个writer的情况下它们之间需要某种锁进行同步作，如果写操作频繁的话RCU的性能会严重下降，所以RCU只适用于读多写少的情况。<font color="red">RCU CPU Stall Detector它有助于检测导致 grace period 过度延迟的因素，因为grace period的长短是RCU性能的重要因素。</font></li></ul><h2 id="rcu-stall-detector相关参数"><a href="#rcu-stall-detector相关参数" class="headerlink" title="rcu stall detector相关参数"></a>rcu stall detector相关参数</h2><p>在 sys 下，提供了两个接口来配置RCU的参数。</p><ul><li><code>/sys/module/rcupdate/parameters/rcu_cpu_stall_timeout</code> 来配置timerout，默认值为21。</li><li><code>/sys/module/rcupdate/parameters/rcu_cpu_stall_suppress</code> 来配置是否输出warning，默认值为0，表示输出。</li></ul><p>具体的参数详见：<code>&lt;Kernel_Dir&gt;/lib/Kconfig.debug</code>文件<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">config RCU_CPU_STALL_TIMEOUT</span><br><span class="line">        <span class="keyword">int</span> <span class="string">"RCU CPU stall timeout in seconds"</span></span><br><span class="line">        depends on RCU_STALL_COMMON</span><br><span class="line">        range <span class="number">3</span> <span class="number">300</span></span><br><span class="line">        <span class="keyword">default</span> <span class="number">60</span> </span><br><span class="line">        help</span><br><span class="line">          If a given RCU grace period extends more than the specified</span><br><span class="line">          number of seconds, a CPU stall warning is printed.  If the</span><br><span class="line">          RCU grace period persists, additional CPU stall warnings are</span><br><span class="line">          printed at more widely spaced intervals.</span><br><span class="line"></span><br><span class="line">config RCU_CPU_STALL_VERBOSE</span><br><span class="line">        <span class="keyword">bool</span> <span class="string">"Print additional per-task information for RCU_CPU_STALL_DETECTOR"</span></span><br><span class="line">        depends on TREE_PREEMPT_RCU</span><br><span class="line">        <span class="keyword">default</span> y</span><br><span class="line">        help</span><br><span class="line">          This option causes RCU to printk detailed per-task information</span><br><span class="line">          <span class="keyword">for</span> any tasks that are stalling the current RCU grace period.</span><br><span class="line"></span><br><span class="line">          Say N <span class="keyword">if</span> you are unsure.</span><br><span class="line"></span><br><span class="line">          Say Y <span class="keyword">if</span> you want to enable such checks.</span><br><span class="line"></span><br><span class="line">config RCU_CPU_STALL_INFO</span><br><span class="line">        <span class="keyword">bool</span> <span class="string">"Print additional diagnostics on RCU CPU stall"</span></span><br><span class="line">        <span class="function">depends <span class="title">on</span> <span class="params">(TREE_RCU || TREE_PREEMPT_RCU)</span> &amp;&amp; DEBUG_KERNEL</span></span><br><span class="line"><span class="function">        <span class="keyword">default</span> n</span></span><br><span class="line"><span class="function">        help</span></span><br><span class="line"><span class="function">          For each stalled CPU that is aware of the current RCU grace</span></span><br><span class="line">          period, print out additional per-CPU diagnostic information</span><br><span class="line">          regarding scheduling-clock ticks, idle state, <span class="keyword">and</span>,</span><br><span class="line">          <span class="keyword">for</span> RCU_FAST_NO_HZ kernels, idle-entry state.</span><br><span class="line"></span><br><span class="line">          Say N <span class="keyword">if</span> you are unsure.</span><br><span class="line"></span><br><span class="line">          Say Y <span class="keyword">if</span> you want to enable such diagnostics.</span><br></pre></td></tr></table></figure><p></p><h2 id="解析rcu-cpu-stall-warning"><a href="#解析rcu-cpu-stall-warning" class="headerlink" title="解析rcu cpu stall warning"></a>解析rcu cpu stall warning</h2><p>常见的一个warning如下：<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[  <span class="number">229.389303</span>] INFO: rcu_sched detected stalls on CPUs/tasks: &#123;&#125; (detected by <span class="number">0</span>, t=<span class="number">5252</span> jiffies, g=<span class="number">51235</span>, c=<span class="number">51234</span>, q=<span class="number">13</span>)</span><br><span class="line">[  <span class="number">229.399881</span>] INFO: Stall ended before state dump start</span><br></pre></td></tr></table></figure><p></p><p>这里的打印在<code>&lt;Kernel_Dir&gt;/kernel/rcu/tree.c</code>中的<code>check_cpu_stall()</code> -&gt; <code>print_other_cpu_stall()</code>函数中打印:</p><blockquote><p>The <code>detected by</code> line indicates which CPU detected the stall (in thiscase, CPU 0), how many jiffies have elapsed since the start of thegrace period (in this case 5252), the number of the last grace periodto start and to complete (51235 and 51234, respectively), and an estimateof the total number of RCU callbacks queued across all CPUs (13 inthis case).</p></blockquote><hr><h1 id="jiffies与HZ和tick的关系"><a href="#jiffies与HZ和tick的关系" class="headerlink" title="jiffies与HZ和tick的关系"></a>jiffies与HZ和tick的关系</h1><p>系统运行时间（以秒为单位）：<code>system_time = (jiffies)/HZ</code></p><ul><li><code>HZ</code>：Linux核心每隔固定周期会发出<code>timer interrupt (IRQ 0)</code>，<code>HZ</code>是用来定义每一秒有几次timer interrupts；使用<code>CONFIG_HZ</code>定义；</li><li><code>tick</code>：是<code>HZ</code>的倒数，意即timer interrupt每发生一次中断的时间。如<code>HZ</code>为250时，<code>tick</code>为4毫秒(millisecond)。</li><li><code>jiffies</code>：为Linux核心变数(32位元变数，unsigned long)，它被用来纪录系统自开机以来，已经过多少的tick。每发生一次timer interrupt，Jiffies变数会被加一。</li></ul><p>以上内容参照：<a href="https://my.oschina.net/armsky/blog/36983" target="_blank" rel="noopener">https://my.oschina.net/armsky/blog/36983</a></p></div><div><div class="my_post_copyright"><script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script><script src="https://cdn.bootcss.com/jquery/2.0.0/jquery.min.js"></script><script src="https://unpkg.com/sweetalert/dist/sweetalert.min.js"></script><p><span>Title:</span><a href="/ca07e9c0/">lockup watchdogs & rcu stall detector</a></p><p><span>Author:</span><a href="/" title="Visit Victor Huang blog">Victor Huang</a></p><p><span>Time:</span>2019-03-17 / 16:03</p><p><span>Link:</span><a href="/ca07e9c0/" title="lockup watchdogs & rcu stall detector">http://wowothink.com/ca07e9c0/</a> <span class="copy-path" title="click to copy link"><i class="fa fa-clipboard" data-clipboard-text="http://wowothink.com/ca07e9c0/" aria-label="copy link success"></i></span></p><p><span>License:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)</a></p></div><script>var clipboard=new Clipboard(".fa-clipboard");$(".fa-clipboard").click(function(){clipboard.on("success",function(){swal({title:"",text:"copy link success",icon:"success",showConfirmButton:!0})})})</script></div><footer class="post-footer"><div class="post-tags"><a href="/tags/Linux-Kernel/" rel="tag"><i class="fa fa-tag"></i> Linux Kernel</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/68aec0df/" rel="next" title="taglist + vim + ctags + cscope"><i class="fa fa-chevron-left"></i> taglist + vim + ctags + cscope</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/5364ebaa/" rel="prev" title="模拟kernel panic并打印堆栈信息">模拟kernel panic并打印堆栈信息 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"></div></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">站点概览</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/images/boy2.jpg" alt="Victor Huang"><p class="site-author-name" itemprop="name">Victor Huang</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">74</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">17</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><span class="site-state-item-count">16</span> <span class="site-state-item-name">标签</span></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="mailto:hsq_encourage@163.com" target="_blank" title="E-Mail"><i class="fa fa-fw fa-envelope"></i>E-Mail</a> </span><span class="links-of-author-item"><a href="https://blog.csdn.net/encourage2011" target="_blank" title="CSDN博客"><i class="fa fa-fw fa-crosshairs"></i>CSDN博客</a></span></div></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#lockup-watchdogs-detector简介"><span class="nav-number">1.</span> <span class="nav-text">lockup watchdogs detector简介</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#lockup-watchdogs-detectors实现机制"><span class="nav-number">2.</span> <span class="nav-text">lockup watchdogs detectors实现机制</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#lockup-watchdogs-detectors常见参数"><span class="nav-number">3.</span> <span class="nav-text">lockup watchdogs detectors常见参数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#watchdog-thresh"><span class="nav-number">3.1.</span> <span class="nav-text">watchdog_thresh</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sample-period"><span class="nav-number">3.2.</span> <span class="nav-text">sample_period</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#watchdog-timer-fn"><span class="nav-number">3.3.</span> <span class="nav-text">watchdog_timer_fn()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#softlockup-panic"><span class="nav-number">3.4.</span> <span class="nav-text">softlockup_panic</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#watchdog-user-enabled"><span class="nav-number">3.5.</span> <span class="nav-text">watchdog_user_enabled</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#watchdog-0-进程CPU占用率高调试方法"><span class="nav-number">4.</span> <span class="nav-text">watchdog/0 进程CPU占用率高调试方法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#rcu-stall-detector简介"><span class="nav-number">5.</span> <span class="nav-text">rcu stall detector简介</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#什么情况下触发rcu-cpu-stall-warning"><span class="nav-number">5.1.</span> <span class="nav-text">什么情况下触发rcu cpu stall warning</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#rcu-stall-detector相关参数"><span class="nav-number">5.2.</span> <span class="nav-text">rcu stall detector相关参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解析rcu-cpu-stall-warning"><span class="nav-number">5.3.</span> <span class="nav-text">解析rcu cpu stall warning</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#jiffies与HZ和tick的关系"><span class="nav-number">6.</span> <span class="nav-text">jiffies与HZ和tick的关系</span></a></li></ol></div></div></section><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span id="scrollpercent"><span>0</span>%</span></div><script type="text/javascript" charset="utf-8" src="/js/tagcloud.js"></script><script type="text/javascript" charset="utf-8" src="/js/tagcanvas.js"></script><div class="widget-wrap"><div id="myCanvasContainer" class="widget tagcloud"><canvas width="200" height="200" id="resCanvas"><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android编译相关/">Android编译相关</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux-Kernel/">Linux Kernel</a><span class="tag-list-count">10</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux-Kernel优化/">Linux Kernel优化</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux-USB/">Linux USB</a><span class="tag-list-count">9</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux-driver/">Linux driver</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux-性能测试/">Linux 性能测试</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python脚本/">Python脚本</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/eMMC/">eMMC</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/i-MX6/">i.MX6</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/i-MX8/">i.MX8</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/u-boot/">u-boot</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ubuntu工具/">ubuntu工具</a><span class="tag-list-count">11</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/备忘记录/">备忘记录</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/碰到的问题/">碰到的问题</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网站记录/">网站记录</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/调试工具/">调试工具</a><span class="tag-list-count">2</span></li></ul></canvas></div></div></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2019</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">Victor Huang</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-area-chart"></i> </span><span class="post-meta-item-text">Site words total count&#58;</span> <span title="Site words total count">87.3k</span></div><div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div></div></footer></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script><script type="text/javascript">function proceedsearch(){$("body").append('<div class="search-popup-overlay local-search-pop-overlay"></div>').css("overflow","hidden"),$(".search-popup-overlay").click(onPopupClose),$(".popup").toggle();var t=$("#local-search-input");t.attr("autocapitalize","none"),t.attr("autocorrect","off"),t.focus()}var isfetched=!1,isXml=!0,search_path="./public/search.xml";0===search_path.length?search_path="search.xml":/json$/i.test(search_path)&&(isXml=!1);var path="/"+search_path,onPopupClose=function(t){$(".popup").hide(),$("#local-search-input").val(""),$(".search-result-list").remove(),$("#no-result").remove(),$(".local-search-pop-overlay").remove(),$("body").css("overflow","")},searchFunc=function(t,e,o){"use strict";$("body").append('<div class="search-popup-overlay local-search-pop-overlay"><div id="search-loading-icon"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div>').css("overflow","hidden"),$("#search-loading-icon").css("margin","20% auto 0 auto").css("text-align","center"),$.ajax({url:t,dataType:isXml?"xml":"json",async:!0,success:function(t){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var n=isXml?$("entry",t).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get():t,r=document.getElementById(e),s=document.getElementById(o),a=function(){var t=r.value.trim().toLowerCase(),e=t.split(/[\s\-]+/);e.length>1&&e.push(t);var o=[];if(t.length>0&&n.forEach(function(n){function r(e,o,n,r){for(var s=r[r.length-1],a=s.position,i=s.word,l=[],h=0;a+i.length<=n&&0!=r.length;){i===t&&h++,l.push({position:a,length:i.length});var p=a+i.length;for(r.pop();0!=r.length&&(s=r[r.length-1],a=s.position,i=s.word,p>a);)r.pop()}return c+=h,{hits:l,start:o,end:n,searchTextCount:h}}function s(t,e){var o="",n=e.start;return e.hits.forEach(function(e){o+=t.substring(n,e.position);var r=e.position+e.length;o+='<b class="search-keyword">'+t.substring(e.position,r)+"</b>",n=r}),o+=t.substring(n,e.end)}var a=!1,i=0,c=0,l=n.title.trim(),h=l.toLowerCase(),p=n.content.trim().replace(/<[^>]+>/g,""),u=p.toLowerCase(),f=decodeURIComponent(n.url),d=[],g=[];if(""!=l&&(e.forEach(function(t){function e(t,e,o){var n=t.length;if(0===n)return[];var r=0,s=[],a=[];for(o||(e=e.toLowerCase(),t=t.toLowerCase());(s=e.indexOf(t,r))>-1;)a.push({position:s,word:t}),r=s+n;return a}d=d.concat(e(t,h,!1)),g=g.concat(e(t,u,!1))}),(d.length>0||g.length>0)&&(a=!0,i=d.length+g.length)),a){[d,g].forEach(function(t){t.sort(function(t,e){return e.position!==t.position?e.position-t.position:t.word.length-e.word.length})});var v=[];0!=d.length&&v.push(r(l,0,l.length,d));for(var $=[];0!=g.length;){var C=g[g.length-1],m=C.position,x=C.word,w=m-20,y=m+80;0>w&&(w=0),y<m+x.length&&(y=m+x.length),y>p.length&&(y=p.length),$.push(r(p,w,y,g))}$.sort(function(t,e){return t.searchTextCount!==e.searchTextCount?e.searchTextCount-t.searchTextCount:t.hits.length!==e.hits.length?e.hits.length-t.hits.length:t.start-e.start});var T=parseInt("1");T>=0&&($=$.slice(0,T));var b="";b+=0!=v.length?"<li><a href='"+f+"' class='search-result-title'>"+s(l,v[0])+"</a>":"<li><a href='"+f+"' class='search-result-title'>"+l+"</a>",$.forEach(function(t){b+="<a href='"+f+'\'><p class="search-result">'+s(p,t)+"...</p></a>"}),b+="</li>",o.push({item:b,searchTextCount:c,hitCount:i,id:o.length})}}),1===e.length&&""===e[0])s.innerHTML='<div id="no-result"><i class="fa fa-search fa-5x" /></div>';else if(0===o.length)s.innerHTML='<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>';else{o.sort(function(t,e){return t.searchTextCount!==e.searchTextCount?e.searchTextCount-t.searchTextCount:t.hitCount!==e.hitCount?e.hitCount-t.hitCount:e.id-t.id});var a='<ul class="search-result-list">';o.forEach(function(t){a+=t.item}),a+="</ul>",s.innerHTML=a}};r.addEventListener("input",a),$(".local-search-pop-overlay").remove(),$("body").css("overflow",""),proceedsearch()}})};$(".popup-trigger").click(function(t){t.stopPropagation(),isfetched===!1?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(onPopupClose),$(".popup").click(function(t){t.stopPropagation()}),$(document).on("keyup",function(t){var e=27===t.which&&$(".search-popup").is(":visible");e&&onPopupClose()})</script><script>!function(){var t=document.createElement("script"),s=window.location.protocol.split(":")[0];"https"===s?t.src="https://zz.bdstatic.com/linksubmit/push.js":t.src="http://push.zhanzhang.baidu.com/push.js";var e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(t,e)}()</script><script type="text/javascript" src="/js/src/clipboard.js"></script><script type="text/javascript" src="/js/src/clipboard-use.js"></script></body></html><!-- rebuild by neat -->